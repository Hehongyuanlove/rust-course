<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust语言圣经(Rust Course)</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/ferris.css">
        <link rel="stylesheet" href="assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="about-book.html">Rust语言圣经</a></li><li class="chapter-item affix "><a href="into-rust.html">进入Rust编程世界</a></li><li class="chapter-item "><a href="first-try/intro.html"><strong aria-hidden="true">1.</strong> 寻找牛刀，以便小试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="first-try/installation.html"><strong aria-hidden="true">1.1.</strong> 安装Rust环境</a></li><li class="chapter-item "><a href="first-try/editor.html"><strong aria-hidden="true">1.2.</strong> 墙推VSCode!</a></li><li class="chapter-item "><a href="first-try/cargo.html"><strong aria-hidden="true">1.3.</strong> 认识Cargo</a></li><li class="chapter-item "><a href="first-try/hello-world.html"><strong aria-hidden="true">1.4.</strong> 不仅仅是Hello world</a></li></ol></li><li class="chapter-item "><a href="basic/intro.html"><strong aria-hidden="true">2.</strong> 基本语法 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/variable.html"><strong aria-hidden="true">2.1.</strong> 变量绑定与结构</a></li><li class="chapter-item "><a href="basic/base-type/index.html"><strong aria-hidden="true">2.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/base-type/numbers.html"><strong aria-hidden="true">2.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="basic/base-type/char-bool.html"><strong aria-hidden="true">2.2.2.</strong> 字符、布尔、元类型</a></li><li class="chapter-item "><a href="basic/base-type/statement-expression.html"><strong aria-hidden="true">2.2.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="basic/base-type/function.html"><strong aria-hidden="true">2.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="basic/ownership/index.html"><strong aria-hidden="true">2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/ownership/ownership.html"><strong aria-hidden="true">2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="basic/ownership/borrowing.html"><strong aria-hidden="true">2.3.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="basic/compound-type/intro.html"><strong aria-hidden="true">2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/scompound-type/tring-slice.html"><strong aria-hidden="true">2.4.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="basic/compound-type/tuple.html"><strong aria-hidden="true">2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="basic/compound-type/struct.html"><strong aria-hidden="true">2.4.3.</strong> 结构体</a></li><li class="chapter-item "><a href="basic/compound-type/enum.html"><strong aria-hidden="true">2.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="basic/compound-type/array.html"><strong aria-hidden="true">2.4.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="basic/flow-control.html"><strong aria-hidden="true">2.5.</strong> 流程控制</a></li><li class="chapter-item "><a href="basic/match-pattern/intro.html"><strong aria-hidden="true">2.6.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/match-pattern/match-if-let.html"><strong aria-hidden="true">2.6.1.</strong> match和if let</a></li><li class="chapter-item "><a href="basic/match-pattern/option.html"><strong aria-hidden="true">2.6.2.</strong> 解构Option</a></li><li class="chapter-item "><a href="basic/match-pattern/pattern-match.html"><strong aria-hidden="true">2.6.3.</strong> 模式和匹配</a></li><li class="chapter-item "><a href="basic/match-pattern/all-patterns.html"><strong aria-hidden="true">2.6.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="basic/method.html"><strong aria-hidden="true">2.7.</strong> 方法Method(todo)</a></li><li class="chapter-item "><a href="basic/generitic.html"><strong aria-hidden="true">2.8.</strong> 泛型(todo)</a></li><li class="chapter-item "><a href="basic/trait.html"><strong aria-hidden="true">2.9.</strong> 特征(todo)</a></li><li class="chapter-item "><a href="basic/type-converse.html"><strong aria-hidden="true">2.10.</strong> 类型转换 todo</a></li><li class="chapter-item "><a href="basic/exception-error.html"><strong aria-hidden="true">2.11.</strong> 返回、异常和错误(todo)</a></li></ol></li><li class="chapter-item "><a href="advance/intro.html"><strong aria-hidden="true">3.</strong> 进阶语法 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advance/collection.html"><strong aria-hidden="true">3.1.</strong> 集合类型(todo)</a></li><li class="chapter-item "><a href="advance/formatted-output.html"><strong aria-hidden="true">3.2.</strong> 格式化输出(todo)</a></li><li class="chapter-item "><a href="advance/comment.html"><strong aria-hidden="true">3.3.</strong> 文档注释(todo)</a></li><li class="chapter-item "><a href="advance/crate-module.html"><strong aria-hidden="true">3.4.</strong> 包和模块(todo)</a></li><li class="chapter-item "><a href="advance/lifetime.html"><strong aria-hidden="true">3.5.</strong> 生命周期(todo)</a></li><li class="chapter-item "><a href="advance/interator.html"><strong aria-hidden="true">3.6.</strong> 迭代器(todo)</a></li><li class="chapter-item "><a href="advance/functional-programing.html"><strong aria-hidden="true">3.7.</strong> 函数式编程(todo)</a></li><li class="chapter-item "><a href="advance/smart-pointer.html"><strong aria-hidden="true">3.8.</strong> 智能指针(todo)</a></li><li class="chapter-item "><a href="advance/global-variable.html"><strong aria-hidden="true">3.9.</strong> 全局变量</a></li></ol></li><li class="chapter-item "><a href="errors/intro.html"><strong aria-hidden="true">4.</strong> 错误处理 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="errors/panic.html"><strong aria-hidden="true">4.1.</strong> panic!</a></li><li class="chapter-item "><a href="errors/result.html"><strong aria-hidden="true">4.2.</strong> 适用Result返回错误</a></li><li class="chapter-item "><a href="errors/user-define.html"><strong aria-hidden="true">4.3.</strong> 自定义错误</a></li><li class="chapter-item "><a href="errors/pretty-format.html"><strong aria-hidden="true">4.4.</strong> 让错误输出更优雅</a></li><li class="chapter-item "><a href="errors/panic-codes.html"><strong aria-hidden="true">4.5.</strong> 会导致panic的代码</a></li></ol></li><li class="chapter-item "><a href="cargo/intro.html"><strong aria-hidden="true">5.</strong> Cargo详解 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/commands.html"><strong aria-hidden="true">5.1.</strong> 常用命令</a></li><li class="chapter-item "><a href="cargo/layout.html"><strong aria-hidden="true">5.2.</strong> 项目结构</a></li><li class="chapter-item "><a href="cargo/cargo-toml-lock.html"><strong aria-hidden="true">5.3.</strong> Cargo.toml和Cargo.lock</a></li><li class="chapter-item "><a href="cargo/dependency.html"><strong aria-hidden="true">5.4.</strong> 依赖管理</a></li><li class="chapter-item "><a href="cargo/cache.html"><strong aria-hidden="true">5.5.</strong> 构建缓存</a></li><li class="chapter-item "><a href="cargo/version.html"><strong aria-hidden="true">5.6.</strong> 版本管理</a></li><li class="chapter-item "><a href="cargo/workspace.html"><strong aria-hidden="true">5.7.</strong> 工作空间</a></li><li class="chapter-item "><a href="cargo/feature.html"><strong aria-hidden="true">5.8.</strong> 条件编译、条件依赖</a></li><li class="chapter-item "><a href="cargo/manifest.html"><strong aria-hidden="true">5.9.</strong> 配置参数(todo)</a></li><li class="chapter-item "><a href="cargo/build-js.html"><strong aria-hidden="true">5.10.</strong> 自定义构建脚本</a></li><li class="chapter-item "><a href="cargo/profile.html"><strong aria-hidden="true">5.11.</strong> Cargo profile</a></li></ol></li><li class="chapter-item "><a href="test/intro.html"><strong aria-hidden="true">6.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="test/unit.html"><strong aria-hidden="true">6.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="test/intergration.html"><strong aria-hidden="true">6.2.</strong> 集成测试</a></li><li class="chapter-item "><a href="test/benchmark.html"><strong aria-hidden="true">6.3.</strong> 性能测试</a></li><li class="chapter-item "><a href="test/ci.html"><strong aria-hidden="true">6.4.</strong> 持续集成</a></li></ol></li><li class="chapter-item "><a href="monitor/intro.html"><strong aria-hidden="true">7.</strong> 日志和监控 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="monitor/log.html"><strong aria-hidden="true">7.1.</strong> 日志</a></li><li class="chapter-item "><a href="monitor/observability.html"><strong aria-hidden="true">7.2.</strong> 可观测性</a></li><li class="chapter-item "><a href="monitor/apm.html"><strong aria-hidden="true">7.3.</strong> 监控(APM)</a></li></ol></li><li class="chapter-item "><a href="smart-pointer/intro.html"><strong aria-hidden="true">8.</strong> 智能指针 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointer/box.html"><strong aria-hidden="true">8.1.</strong> Box对象(todo)</a></li><li class="chapter-item "><a href="smart-pointer/deref-drop.html"><strong aria-hidden="true">8.2.</strong> Deref和Drop特征(todo)</a></li><li class="chapter-item "><a href="smart-pointer/rc-refcell.html"><strong aria-hidden="true">8.3.</strong> Rc与RefCell(todo)</a></li><li class="chapter-item "><a href="smart-pointer/self-referrence.html"><strong aria-hidden="true">8.4.</strong> 自引用与内存泄漏(todo)</a></li></ol></li><li class="chapter-item "><a href="traits/intro.html"><strong aria-hidden="true">9.</strong> 常见特征解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">9.1.</strong> 类型转换From/Into</a></li><li class="chapter-item "><a href="traits/as-ref-as-mut.html"><strong aria-hidden="true">9.2.</strong> AsRef, AsMut</a></li><li class="chapter-item "><a href="traits/borrow-family.html"><strong aria-hidden="true">9.3.</strong> Borrow, BorrowMut, ToOwned</a></li><li class="chapter-item "><a href="traits/deref.html"><strong aria-hidden="true">9.4.</strong> Deref和引用隐式转换</a></li><li class="chapter-item "><a href="traits/cow.html"><strong aria-hidden="true">9.5.</strong> 写时拷贝Cow</a></li></ol></li><li class="chapter-item "><a href="multi-threads/intro.html"><strong aria-hidden="true">10.</strong> 多线程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="multi-threads/thread.html"><strong aria-hidden="true">10.1.</strong> 线程管理(todo)</a></li><li class="chapter-item "><a href="multi-threads/message-passing.html"><strong aria-hidden="true">10.2.</strong> 消息传递(todo)</a></li><li class="chapter-item "><a href="multi-threads/ref-counter-lock.html"><strong aria-hidden="true">10.3.</strong> 数据共享Arc、Mutex、Rwlock(todo)</a></li><li class="chapter-item "><a href="multi-threads/races.html"><strong aria-hidden="true">10.4.</strong> 数据竞争(todo)</a></li><li class="chapter-item "><a href="multi-threads/send-sync.html"><strong aria-hidden="true">10.5.</strong> Send、Sync(todo)</a></li></ol></li><li class="chapter-item "><a href="memory/intro.html"><strong aria-hidden="true">11.</strong> 深入内存 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory/pointer-ref.html"><strong aria-hidden="true">11.1.</strong> 指针和引用(todo)</a></li><li class="chapter-item "><a href="memory/uninit.html"><strong aria-hidden="true">11.2.</strong> 未初始化内存(todo)</a></li><li class="chapter-item "><a href="memory/allocation.html"><strong aria-hidden="true">11.3.</strong> 内存分配(todo)</a></li><li class="chapter-item "><a href="memory/layout.html"><strong aria-hidden="true">11.4.</strong> 内存布局(todo)</a></li><li class="chapter-item "><a href="memory/virtual.html"><strong aria-hidden="true">11.5.</strong> 虚拟内存(todo)</a></li></ol></li><li class="chapter-item "><a href="networking/intro.html"><strong aria-hidden="true">12.</strong> 网络和异步编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="networking/tcp.html"><strong aria-hidden="true">12.1.</strong> TCP和网络原理(todo)</a></li><li class="chapter-item "><a href="networking/concurrency-parallelism.html"><strong aria-hidden="true">12.2.</strong> 并发与并行(todo)</a></li><li class="chapter-item "><a href="networking/async/intro.html"><strong aria-hidden="true">12.3.</strong> 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="networking/async/async-await.html"><strong aria-hidden="true">12.3.1.</strong> async/await语法</a></li><li class="chapter-item "><a href="networking/async/future/into.html"><strong aria-hidden="true">12.3.2.</strong> future详解</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="networking/async/future/future.html"><strong aria-hidden="true">12.3.2.1.</strong> 何为Future</a></li><li class="chapter-item "><a href="networking/async/future/task-schedule.html"><strong aria-hidden="true">12.3.2.2.</strong> 任务调度</a></li><li class="chapter-item "><a href="networking/async/future/task-excutor.html"><strong aria-hidden="true">12.3.2.3.</strong> 任务执行器</a></li><li class="chapter-item "><a href="networking/async/future/system-io.html"><strong aria-hidden="true">12.3.2.4.</strong> 系统IO</a></li><li class="chapter-item "><a href="networking/async/future/multi-futures.html"><strong aria-hidden="true">12.3.2.5.</strong> 执行多个Future</a></li></ol></li><li class="chapter-item "><a href="networking/async/pin-unpin.html"><strong aria-hidden="true">12.3.3.</strong> Pin、Unpin(todo)</a></li><li class="chapter-item "><a href="networking/async/future/workarounds.html"><strong aria-hidden="true">12.3.4.</strong> 遇到不支持的异步特性?</a></li><li class="chapter-item "><a href="networking/async/http.html"><strong aria-hidden="true">12.3.5.</strong> HTTP Client/Server</a></li><li class="chapter-item "><a href="networking/async/tokio/intro.html"><strong aria-hidden="true">12.3.6.</strong> 定海神针-tokio包</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="networking/async/tokio/basic.html"><strong aria-hidden="true">12.3.6.1.</strong> 基本用法</a></li><li class="chapter-item "><a href="networking/async/tokio/stream.html"><strong aria-hidden="true">12.3.6.2.</strong> 异步消息流</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="traps/intro.html"><strong aria-hidden="true">13.</strong> 常见陷阱 todo</a></li><li class="chapter-item "><a href="style-guide/intro.html"><strong aria-hidden="true">14.</strong> 代码规范 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="style-guide/naming.html"><strong aria-hidden="true">14.1.</strong> 命名规范</a></li><li class="chapter-item "><a href="style-guide/code.html"><strong aria-hidden="true">14.2.</strong> 代码风格(todo)</a></li><li class="chapter-item "><a href="style-guide/mark.html"><strong aria-hidden="true">14.3.</strong> 代码标记</a></li><li class="chapter-item "><a href="style-guide/clippy.html"><strong aria-hidden="true">14.4.</strong> Clippy</a></li></ol></li><li class="chapter-item "><a href="object-oriented/intro.html"><strong aria-hidden="true">15.</strong> 面向对象 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="object-oriented/characteristics.html"><strong aria-hidden="true">15.1.</strong> 为何OO(todo)</a></li><li class="chapter-item "><a href="object-oriented/trait-object.html"><strong aria-hidden="true">15.2.</strong> 特征对象</a></li><li class="chapter-item "><a href="object-oriented/design-pattern.html"><strong aria-hidden="true">15.3.</strong> 设计模式</a></li></ol></li><li class="chapter-item "><a href="unsafe/intro.html"><strong aria-hidden="true">16.</strong> 不安全Rust todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/raw-pointer.html"><strong aria-hidden="true">16.1.</strong> 原生指针(todo)</a></li><li class="chapter-item "><a href="unsafe/modify-global-var.html"><strong aria-hidden="true">16.2.</strong> 修改全局变量</a></li><li class="chapter-item "><a href="unsafe/ffi.html"><strong aria-hidden="true">16.3.</strong> FFI外部语言用</a></li></ol></li><li class="chapter-item "><a href="fight-with-compiler/intro.html"><strong aria-hidden="true">17.</strong> 对抗编译检查 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fight-with-compiler/phantom-data.html"><strong aria-hidden="true">17.1.</strong> 幽灵数据(todo)</a></li><li class="chapter-item "><a href="fight-with-compiler/lifetime.html"><strong aria-hidden="true">17.2.</strong> 生命周期(todo)</a></li><li class="chapter-item "><a href="fight-with-compiler/unconstrained.html"><strong aria-hidden="true">17.3.</strong> 类型未限制(todo)</a></li></ol></li><li class="chapter-item "><a href="macro/intro.html"><strong aria-hidden="true">18.</strong> 宏编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macro/procedure-macro.html"><strong aria-hidden="true">18.1.</strong> 过程宏(todo)</a></li></ol></li><li class="chapter-item "><a href="performance/intro.html"><strong aria-hidden="true">19.</strong> 性能调优 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="performance/clone-copy.html"><strong aria-hidden="true">19.1.</strong> Clone和Copy</a></li><li class="chapter-item "><a href="performance/benchmark.html"><strong aria-hidden="true">19.2.</strong> Benchmark性能测试(todo)</a></li><li class="chapter-item "><a href="performance/runtime-check.html"><strong aria-hidden="true">19.3.</strong> 减少Runtime check(todo)</a></li></ol></li><li class="chapter-item "><a href="compiler/intro.html"><strong aria-hidden="true">20.</strong> 编译器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/attributes.html"><strong aria-hidden="true">20.1.</strong> 常见属性标记</a></li></ol></li><li class="chapter-item "><a href="std/intro.html"><strong aria-hidden="true">21.</strong> 标准库解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/search.html"><strong aria-hidden="true">21.1.</strong> 如何寻找你想要的内容</a></li></ol></li><li class="chapter-item "><a href="libraries/intro.html"><strong aria-hidden="true">22.</strong> 常用三方库 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="libraries/json/intro.html"><strong aria-hidden="true">22.1.</strong> JSON</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="libraries/json/serde.html"><strong aria-hidden="true">22.1.1.</strong> serde(todo)</a></li></ol></li><li class="chapter-item "><a href="libraries/http/intro.html"><strong aria-hidden="true">22.2.</strong> HTTP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="libraries/http/reqwest.html"><strong aria-hidden="true">22.2.1.</strong> reqwest(todo)</a></li></ol></li><li class="chapter-item "><a href="libraries/command/intro.html"><strong aria-hidden="true">22.3.</strong> 命令行解析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="libraries/command/structopt.html"><strong aria-hidden="true">22.3.1.</strong> structopt(todo)</a></li></ol></li></ol></li><li class="chapter-item "><a href="templates/intro.html"><strong aria-hidden="true">23.</strong> 场景模版 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="templates/files/intro.html"><strong aria-hidden="true">23.1.</strong> 文件操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="templates/files/dir.html"><strong aria-hidden="true">23.1.1.</strong> 目录(todo)</a></li></ol></li><li class="chapter-item "><a href="templates/http/intro.html"><strong aria-hidden="true">23.2.</strong> Http请求(todo)</a></li></ol></li><li class="chapter-item "><a href="appendix/intro.html"><strong aria-hidden="true">24.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="appendix/keywords.html"><strong aria-hidden="true">24.1.</strong> A-关键字</a></li><li class="chapter-item "><a href="appendix/operators.html"><strong aria-hidden="true">24.2.</strong> B-运算符与符号</a></li><li class="chapter-item "><a href="appendix/derive.html"><strong aria-hidden="true">24.3.</strong> C-派生特征derive</a></li><li class="chapter-item "><a href="appendix/rust-version.html"><strong aria-hidden="true">24.4.</strong> D-Rust版本发布</a></li><li class="chapter-item "><a href="appendix/rust-dev.html"><strong aria-hidden="true">24.5.</strong> E-Rust自身开发流程</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rustcollege" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust语言圣经"><a class="header" href="#rust语言圣经">Rust语言圣经</a></h1>
<p>做任何事情，初心和目标很重要，过程也很重要，那么这里我们就来谈谈这些，关于书，关于Rust在国内的发展。<em>强烈建议读者大大们不要跳过下面的内容，对于你对这本书的理解和定位会很有帮助</em>。</p>
<h2 id="关于本书"><a class="header" href="#关于本书">关于本书</a></h2>
<ul>
<li>官方书名： Rust语言圣经(Rust Course)</li>
<li>官方网址： https://course.rs</li>
<li>修订时间： 尚未发行</li>
<li>Rust版本：Rust edition 2021</li>
<li>QQ交流群： 1009730433</li>
</ul>
<h4 id="书本简介"><a class="header" href="#书本简介">书本简介</a></h4>
<p><code>Rust语言圣经</code>是一本涵盖了从入门到精通各个阶段的Rust书籍，书本的章节和内容组织经过深思熟虑的设计，以符合中国用户的编程使用习惯，目的是尽量对新手更友好，同时也更方便老手的后期检索查询。</p>
<p>使用Rust的用户往往都对性能非常感兴趣，因此本书对于性能优化方面也是分散落入各个章节中，同时还有一个专门的<a href="./performance/intro.html">性能优化</a>专题，来帮助用户系统的认识如何优化Rust项目的性能。</p>
<p>针对不同的使用场景，我们也给出了多种模版代码，方便用户直接复制粘贴到代码中，例如读取文件、http请求等，无需再去网上搜索。</p>
<p>Rust的外部库层次不齐，针对这一点，我们根据功能分类推荐了相应的高质量开源库，同时提供了基础的使用帮助。</p>
<p><strong>在学完这本书后，你也会随之完成数个小型项目</strong>，例如其中一些是：</p>
<ul>
<li>Mandelbrot集合渲染</li>
<li>类Grep命令</li>
<li>CPU模拟器</li>
<li>小型数据库</li>
<li>小型Redis</li>
<li>HTTP等网络请求客户端</li>
<li>小型操作系统内核</li>
</ul>
<p>从上面的列表可以看出，学完本书，不仅会教会你Rust语言，还能学到系统编程和底层编程, 尽情享受奇妙的编程之旅吧。</p>
<h4 id="创作初心"><a class="header" href="#创作初心">创作初心</a></h4>
<p>还有很多，就不一一列举，等待大家自己去探索挖掘。 总之在写作过程中我们始终铭记初心：<strong>为用户打造一本真正的Rust中文好书。 新手用来入门，老手用来提高，高手能用来提升生产力</strong>。</p>
<h4 id="目标读者"><a class="header" href="#目标读者">目标读者</a></h4>
<p>目标读者大致能落在以下三个范畴内</p>
<ol>
<li>有其它语言编程基础，无Rust编程语言经验的爱好者</li>
<li>已经熟悉Rust想要更进一步的中级Rust程序员</li>
<li>想要随时检索一些Rust知识和代码，对生产力有要求的Rust开发者</li>
</ol>
<h4 id="内容说明"><a class="header" href="#内容说明">内容说明</a></h4>
<p>书的目录组织结构和内容组织完全是原创，其中书籍内容部分，大部分是原创，另外一部分来源于外文资料及中文翻译书籍。</p>
<p>来源于中文翻译书籍的内容都会标明来源，在复制粘贴的同时，还进行了大量的修改，一个是增加中文翻译的准确性，还有就是提升阅读流畅度，让行文更符合中国人的阅读习惯，摆脱“机器翻译味&quot;, <strong>所以本书的内容每句话都是经过精心构思，力求提供给大家最好的阅读体验</strong>.</p>
<h2 id="版权信息"><a class="header" href="#版权信息">版权信息</a></h2>
<p>Rust语言圣经是完全开源的电子书籍，但是也应该受到版权的保护，毕竟凝聚了大家多个数以百计小时的汗水、牺牲了大量陪伴家人的时间，才完成了该书。</p>
<p>因此我们选择了<a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwigkv-KtMT0AhXFdXAKHdI4BCcQFnoECAQQAw&amp;url=https%3A%2F%2Fchoosealicense.com%2Fno-permission%2F&amp;usg=AOvVaw3M2Q4IbdhnpJ2K71TF7SPB">No License</a>作为我们的版权，这意味着读者可以随意的fork、阅读，但是不能私下修改后再分发，如果想要修改，请提RP或者加入Rust编程学院，成为正式成员。</p>
<h2 id="阅读本书需要注意的点"><a class="header" href="#阅读本书需要注意的点">阅读本书需要注意的点</a></h2>
<h3 id="命令行符号"><a class="header" href="#命令行符号">命令行符号</a></h3>
<blockquote>
<p>在本章以及整本书中，我们将展示一些在终端中使用的命令。在终端中输入的行均以 <code>$</code> 开头，你不需输入 <code>$</code> 字符；它表示每个命令的开始。不以 <code>$</code> 开头的行通常表示上一个命令的输出内容。另外，专用于 PowerShell 的示例将使用 <code>&gt;</code> 而不是 <code>$</code>。</p>
</blockquote>
<h4 id="编译期望行为说明"><a class="header" href="#编译期望行为说明">编译期望行为说明</a></h4>
<table><thead><tr><th>Ferris</th><th>意义</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>这些代码不能编译！</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>这些代码会 panic！</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>这些代码没有产生期望的行为。</td></tr>
</tbody></table>
<p>在大部分情况，我们会指引你将任何不能编译的代码纠正为正确版本。</p>
<h2 id="rust社区"><a class="header" href="#rust社区">Rust社区</a></h2>
<p>与国外的Rust发展如火如荼相比，国内的近况不是特别理想。</p>
<p>导致目前这种状况的原因，我个人认为有以下几点原因：</p>
<ol>
<li>上手难度大，学习曲线陡峭</li>
<li>中文资料少，英文资料难学(基于原因1)</li>
<li>没有体系化的学习路线，新人往往扫完一遍入门书籍，就不知道何去何从</li>
</ol>
<p>因此我联合几个朋友一起创建了Rust编程学院(Rust College), 致力于给国内提供最新、最高质量Rust学习内容。</p>
<p>官网网址:</p>
<ul>
<li>https://college.rs</li>
<li>QQ群： 1009730433</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进入rust编程世界"><a class="header" href="#进入rust编程世界">进入Rust编程世界</a></h1>
<h2 id="一rust发展历程"><a class="header" href="#一rust发展历程">一、Rust发展历程</a></h2>
<p>Rust 最早是 Mozilla 雇员 Graydon Hoare 的一个个人项目，从 2009 年开始，得到了 Mozilla 研究院的支助，2010 年项目对外公布。2010 ～2011 年间实现的自举。从此以后，Rust 经历了巨大的设计变化和反复（历程极其艰辛），终于在 2015 年 5 月 15日发布了 1.0 版。在这个研发过程中，Rust 建立了一个强大活跃的社区，形成了一整套完善稳定的项目贡献机制（Rust能够飞速发展，与这一点密不可分）。Rust 现在由 <a href="https://github.com/rust-lang/rust">Rust项目开发者社区</a>维护。</p>
<p>大家可能疑惑Rust为啥用了这么久才到1.0版本？与之相比，Go语言2009年发布，却在2012年仅用3年就发布了1.0版本。首先是因为Rust语言特性较为复杂，因此需要全盘考虑的问题非常多；其次，Rust当时的参与者太多了，七嘴八舌的声音也很多，导致了众口难调，而Rust开发团队又非常重视社区的意见 ；最后，一旦1.0快速发布，那么后续大部分语言特性就无法再修改，对于有完美强迫症的Rust开发者团队来说，某种程度上的不完美是不可接受的。因此，Rust语言用了足足6年时间，才发布了尽善尽美的1.0版本。</p>
<h2 id="二使用现状"><a class="header" href="#二使用现状">二、使用现状</a></h2>
<p>一般来说，一门编程语言能在某一年成为全世界最受欢迎的语言，那锣鼓喧天、昂首挺胸都是少不了的，没办法，能从全世界这么多编程语言中脱颖而出成为最受欢迎的语言，属实困难。可是有一门语言，它从发布1.0版本开始，连续6年成为了全世界最受欢迎的语言，是的，它就是Rust,这不，2021年又成为最受欢迎的语言了。</p>
<p>你可能会想，既然这么受欢迎，那肯定使用很广吧？可惜现实给了我们重重一击：在国外，Rust尚且还行，在各大公司的基础服务和底层都屡见身影，在github上也算是呼风唤雨，可是到了国内，说句不好听的，能听说过Rust大名的，已经算百里挑一的优秀了，就业环境更是糟糕。</p>
<p>如何改变这一切？这就是<a href="https://college.rs">Rust编程学院</a>想做的事情，通过大家一起的努力，达成以下目标：</p>
<ol>
<li>输出<strong>成体系的学习教程</strong>，大幅降低Rust的学习和使用难度</li>
<li>打造<strong>至少一个全民级项目</strong>，提升Rust在国内知名度</li>
<li>建立一个持续活跃的社区，为Rust用户提供一个交流、解惑的平台</li>
</ol>
<p>其中第一点是尤为重要的，只有一套成体系的学习教程，才能让用户快速上手并且喜欢上Rust语言，一旦粉丝效应形成，那么Rust在国内的影响力就会在大家的自发宣传下迅速提升。</p>
<h4 id="部分主要使用者"><a class="header" href="#部分主要使用者">部分主要使用者</a></h4>
<ul>
<li>AWS从2017年开始就用Rust实现了它们的无服务器计算平台： AWS Lambda 和 AWS Fargate, 并且用Rust重写了Bottlerocket OS和AWS Nitro系统，这两个是弹性计算云(EC2)的重要服务</li>
<li>Cloudflare也是Rust的重度用户，DNS、无服务计算、网络包监控等灯</li>
<li>Dropbox的底层存储服务完全由Rust重写，达到了数万PB的规模</li>
<li>Google除了在安卓系统的部分模块中使用Rust外，还在它最新的操作系统fuchsia中重度使用Rust</li>
<li>Facebook使用Rust来增强自己的网页端、移动端和API服务的性能，同时还写了Hack编程语言的虚拟机部分模块</li>
<li>Microsoft使用Rust为Azure平台实现了一些组件，其中包括IoT服务的安全守护服务</li>
<li>githu和npmjs.com，使用Rust提供了高达每天13亿次的npm包下载数量</li>
<li>Rust目前已经成为全世界区块链平台的首选开发语言</li>
<li>Tidb，国内最有名的开源分布式数据库</li>
<li>国内高频交易服务</li>
</ul>
<p>类似的还有很多，总之Rust的发展态势非常喜人，生态发展也异常迅速，颇有燎原之火之势。</p>
<h4 id="github"><a class="header" href="#github">Github</a></h4>
<p>Github上的Rust项目可以在这里查看: https://github.com/topics/rust?l=rust，里面的项目是按照star数降序排列。</p>
<h2 id="三适用人群"><a class="header" href="#三适用人群">三、适用人群</a></h2>
<p>Rust 因多种原因适用于很多开发者。让我们讨论几个最重要的群体。</p>
<h3 id="开发者团队"><a class="header" href="#开发者团队">开发者团队</a></h3>
<p>由于Rust语言拥有异常强大的编译器和语言特性，因此Rust的代码天然就会比其它语言有更少的Bug，同时Rust拥有非常完善的工具链、最好的包管理工具，这些叠加在一起，决定了Rust非常适合大型开发者团队的协作开发。</p>
<p>也许Rust在开发速度上不是最快的，但是从开发 + 维护的角度来看，这个成本绝对是各个语言中最小的之一，当然如果你的公司就追求做出来能用就行，那Rust确实不太适合。</p>
<h3 id="学生"><a class="header" href="#学生">学生</a></h3>
<p>Rust的语言特点决定了它天然就跟底层系统很亲和，通过Rust你能学到操作系统、网络等计算机原理，现在不少名校都引入了Rust作为计算机系统课程学习的重要组成部分，例如MIT对Rust的使用就非常广泛。</p>
<p>同时Rust具有一个友善、活跃的社区，社区中的人非常热衷于为大家解答问题，因此也很适合学生学习一门新的恶语言。</p>
<h3 id="公司"><a class="header" href="#公司">公司</a></h3>
<p>数以百计的公司，无论规模大小，都在生产中使用Rust来完成各种任务。这些任务包括命令行工具、web 服务、DevOps 工具、嵌入式设备、音视频分析与转码、加密货币（cryptocurrencies）、生物信息学（bioinformatics）、搜索引擎、物联网（internet of things, IOT）程序、机器学习、云计算等，甚至还包括 Firefox 浏览器的大部分内容。</p>
<h3 id="开源开发者"><a class="header" href="#开源开发者">开源开发者</a></h3>
<p>Rust连续6年成为全世界最受欢迎的语言，这个就是来自于开源社区的厚爱，在github上，Rust目前各种类型的开源项目都非常火，同时有很多领域还等着大家去填补空白，这些都意味着在开源世界扬名立万的机会。</p>
<p>为一门成熟的语言锦上添花，远不如为一门新语言雪中送炭，你能获得比在其他语言更多的star和名气。</p>
<h3 id="重视速度和稳定性的开发者"><a class="header" href="#重视速度和稳定性的开发者">重视速度和稳定性的开发者</a></h3>
<p>速度分为两种：运行速度和开发速度。</p>
<p>开发速度方面，Rust拥有和C、C++几乎相当的性能，甚至由于Rust的各种零开销抽象以及安全的编程方式，你能轻松写出和那些优化过后的C++代码一样甚至更高的性能: <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>就是很典型的例子。</p>
<p>同时，在你熟悉Rust后，由于强大的编译器、标准库文档、语言高级特性等，Rust能让你拥有不属于其它静态语言的开发速度，同时大幅减少后期维护成本。</p>
<p>最后，Rust语言不仅仅适用于这些人群，这些列出来的只是从Rust中最受益的人群。总的来说Rust的目标是消除数十年来程序员不得不做的权衡：安全 <strong>与</strong> 生产力，速度 <strong>与</strong> 工程性。</p>
<p>请跟随本书的脚步去尝试下Rust，看看这个选择是否适合你。</p>
<h2 id="四rust语言版本更新"><a class="header" href="#四rust语言版本更新">四、Rust语言版本更新</a></h2>
<p>与其它语言相比，Rust的更新迭代较为频繁(得益于精心设计过的发布流程以及Rust语言开发者团队管理)：</p>
<ul>
<li>每6周发布一个迭代版本</li>
<li>2-3年发布一个新的大版本：Rust 2018 edition，Rust 2021 edtion</li>
</ul>
<p>好处在于，可以满足不同的用户群体的需求：</p>
<ul>
<li>对于活跃的Rust用户，他们总是能很快获取到新的语言内容，毕竟，尝鲜是技术爱好者的共同特点:)</li>
<li>对于一般的用户，edition的发布会告诉这些用户：Rust语言相比上次大版本发布，有了重大的改进，值得一看</li>
<li>对于Rust语言开发者，可以让他们的工作成果更快的被世人所知，不必锦衣夜行</li>
</ul>
<p>好了，相信大家听了这么多Rust的优点，已经迫不及待想要开始学习旅程，OK，let's go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="寻找牛刀以便小试"><a class="header" href="#寻找牛刀以便小试">寻找牛刀，以便小试</a></h1>
<p>其实对于写这种章节，我内心是拒绝的，因为真的很无趣，对于一本书而言，这也更像是一种浪费纸张的行为(好在咱无纸化:-D),不过没有办法，没有Rust，总不能让大家用空气运行吧, so, 我恶趣味的起了一个这样的章节名。</p>
<p>在本章中，你将学习以下内容：</p>
<ol>
<li>在Macos、Linux、Windows上安装Rust以及相关工具链</li>
<li>搭建Vscode所需的环境</li>
<li>简单介绍Cargo</li>
<li>实现一个酷炫多国语言版本的“世界，你好”的程序,并且谈谈对Rust语言的初印象</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装rust"><a class="header" href="#安装rust">安装Rust</a></h1>
<p>强烈建议使用<code>rustup</code>来安装Rust，当然如果你有异心，请寻找其它安装方式，然后再从下一节开始阅读。</p>
<blockquote>
<p>haha,开个玩笑，读者乃大大，怎么能弃之不顾，所以，注意：如果你不想用或者不能用rustup，请参见<a href="https://forge.rust-lang.org/infra/other-installation-methods.html#other-rust-installation-methods">Rust其它安装方法</a></p>
</blockquote>
<p>现在Rust稳定版特性越来越全了，所以下载最新稳定版本即可。由于你用的Rust版本可能跟本书写的时候不一样，所以一些编译错误和警告可能也会有所不同。</p>
<h3 id="在-linux-或-macos-上安装-rustup"><a class="header" href="#在-linux-或-macos-上安装-rustup">在 Linux 或 macOS 上安装 <code>rustup</code></a></h3>
<p>如果你使用的是 Linux 或 macOS，打开终端并输入下面命令：</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>这个命令将下载一个脚本并开始安装 <code>rustup</code> 工具，此工具将安装 <code>Rust</code> 的最新稳定版本。可能会提示你输入管理员密码。如果安装成功，将出现下面这行：</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>注意,上面已经完成了Rust安装，<strong>如果你在安装过程中遇到连接器错误，请继续往下看</strong>，否则可以直接跳到<a href="first-try/installation.html#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%B8%E8%BD%BD">更新和卸载</a>，继续阅读.</p>
<p>Rust对运行环境和Go语言很像，几乎所有环境都可以无需安装任何依赖直接运行，但是，Rust会依赖libc和链接器linker,所以如果遇到了提示链接器无法执行的错误，你需要手动安装一个C语言编译器即可:</p>
<p><strong>在Macos下</strong></p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p><strong>在linux下</strong>
Linux 用户一般应按照相应发行版的文档来安装 GCC 或 Clang。例如，如果你使用 Ubuntu，则可安装 <code>build-essential</code>。</p>
<h3 id="在-windows-上安装-rustup"><a class="header" href="#在-windows-上安装-rustup">在 Windows 上安装 <code>rustup</code></a></h3>
<p>windows上安装过程较为麻烦，因此我们专门写了一篇文章来讲解相关的安装过程，请移步：<a href="first-try/">Windows安装</a></p>
<h3 id="更新和卸载"><a class="header" href="#更新和卸载">更新和卸载</a></h3>
<p>通过 <code>rustup</code> 安装 Rust 后，更新到最新版本很简单。在 shell 中运行以下更新命令：</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>要卸载 <code>Rust</code> 和 <code>rustup</code>，在 shell 中运行以下卸载命令：</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="疑难解答"><a class="header" href="#疑难解答">疑难解答</a></h3>
<p>要检查是否正确安装了 Rust，可打开 shell 并输入下面这行,你应该看到最新发布的稳定版本的版本号、提交哈希值和提交日期:</p>
<pre><code class="language-console">$ rustc -V
rustc 1.56.1 (59eed8a2a 2021-11-01)
</code></pre>
<p>如果你看到此信息，则说明您已成功安装 Rust！如果没看到此信息，并且你使用的是 Windows，请检查 Rust 是否在 <code>%PATH%</code> 系统变量中。如果都正确，但 <code>Rust</code> 仍然无法正常工作，那么你可以在很多地方获得帮助。最简单的是<strong>加入Rust编程学院这个大家庭，QQ群：1009730433</strong>.</p>
<h3 id="本地文档"><a class="header" href="#本地文档">本地文档</a></h3>
<p>Rust 的安装还自带文档的本地副本，可以方便地离线阅读。运行 <code>rustup doc</code> 让浏览器打开本地文档。</p>
<p>每当遇到标准库提供的类型或函数不知道怎么用时，都可以在 API 文档中查找到！具体参加<a href="first-try/../std/search.html">在标准库寻找你想要的内容</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="墙推vscode"><a class="header" href="#墙推vscode">墙推VScode!</a></h2>
<p>VScode从15年刚开始推出，我就在使用了，做为第一个吃螃蟹的人，可以说见证了它一路的快速发展，直到现在成为开源世界最火的IDE之一(弱弱的说一句，之一也许可以去掉).顺便歪楼说一句：我预言过三件事, 在13年预言Golang会火遍全世界,同时创建了14-19年最火的Golang隐修会社区，可惜因为某些原因被封停了，甚是遗憾；在15年预言VScode会成为世界上最好的ide；我是jaeger tracing项目的第一个star用户(是的，比作者还早)，当时就很看好这个项目的后续发展。</p>
<p>现在呢，我在这里正式预言，未来Rust会成为最火的系统编程语言，在应用开发之外的领域会大放光彩！</p>
<p>下面继续简单介绍下VScode,以下内容引用于官网：</p>
<blockquote>
<p>Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。它内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。Visual Studio Code是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比 Diff、GIT命令 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。</p>
</blockquote>
<h2 id="安装vscode的rust插件"><a class="header" href="#安装vscode的rust插件">安装Vscode的Rust插件</a></h2>
<p>在VScode的左侧扩展目录里，搜索<code>rust</code>,你能看到两个Rust插件，如果没有意外，这两个应该分别排名第一和第二:</p>
<ol>
<li>官方的<code>Rust</code>，作者是<code>The Rust Programming Language</code>, 官方出品，牛逼就完了，但是。。。我们并不推荐，这个插件有几个问题:</li>
</ol>
<ul>
<li>首先是在代码跳转上支持的很烂，只能在自己的代码库中跳转，一旦跳到别的三方库，那就无法继续跳转，对于查看标准库和三方库的源码带来了极大的困扰</li>
<li>其次，不支持类型自动标注，对于Rust语言而言，类型说明是非常重要的，特别是在你不知道给变量一个什么类型时，这种IDE的自动提示就变得弥足珍贵</li>
<li>代码提示不太好用，有些方法即不提示，也不能跳转</li>
</ul>
<ol start="2">
<li>社区驱动的<code>rust-analyzer</code>，非常推荐，上面说的所有问题，在这个插件上都得到了解决，不得不说，rust社区 yyds!</li>
</ol>
<p>所以，综上所述，我们选择<code>rust-analyer</code>作为Rust语言的插件，具体的安装很简单，点击插件，选择安装即可，根据提示可能需要重新加载ide。</p>
<p>ide安装完成后，在第一次打开Rust项目时，需要安装一些依赖，具体的状态在左下角会进行提示，包括下载、代码构建building等。</p>
<p>在插件默认设置下，每一次保存代码，都会出进行一次重新编译，如果你的电脑慢，有一点一定要注意：在编译器构建代码的同时，不要在终端再运行<code>cargo run</code>等命令进行编译，不然会获得一个报错提示，大意是当前文件目录已经被锁定，等待其它使用者释放，如果等了很久ide还是没有释放(虽然我没遇到过，但是存在这个可能性)，你可以关掉ide，并手动kill掉<code>rust-anylyzer</code>，然后重新尝试即可。</p>
<blockquote>
<p>在搜索VScode插件时，报错：<code>提取扩展出错，XHR failed</code>，这个报错是因为网络原因导致，很可能是你的网络不行或者翻墙工具阻拦你的访问，试着关掉翻墙，再进行尝试</p>
</blockquote>
<h2 id="安装其它好用的插件"><a class="header" href="#安装其它好用的插件">安装其它好用的插件</a></h2>
<p>在此，再推荐大家几个好用的插件：</p>
<ol>
<li>Better TOML，用于更好的展示.toml文件</li>
<li>Error Lens, 更好的获得错误展示</li>
<li>One Dark Pro, 非常好看的Vscode主题</li>
<li>CodeLLDB, debugger程序</li>
</ol>
<p>好了，至此，Vscode的配置就已经全部结束，是不是很简单？下面让我们来用Cargo创建一个Rust项目，然后用Vscode打开.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="认识cargo"><a class="header" href="#认识cargo">认识Cargo</a></h2>
<p>但凡经历过C/C++、Go语言1.10版本之前的用户都知道，一个好的包管理工具有多么的重要！！我们那个时候时如此的羡慕nodejs的npm包管理，但是却求而不得，包管理工具最重要的意义就是<strong>任何用户拿到你的代码，都能运行起来</strong>&quot;，而不会因为各种包版本依赖焦头烂额，Go语言在1.10版本之前，所有的包都是在github.com下存放，导致了所有的项目都公用一套依赖代码，在本地项目复杂后，这简直是一种依赖。</p>
<p>说多了都是泪，笔者目前还有一个早期Go的项目(15年写的)，用到了iris(一个坑爹http服务)，结果现在运行不起来了，因为找不到iris当时的那个版本！！</p>
<p>作为一门现代化语言，<code>Rust</code>吸收了多个语言的包管理优点，为大家提供超级大杀器：<code>cargo</code>，真的，但凡用过后，你都不会想要其他语言的包管理工具了。</p>
<p>总而言之，<code>cargo</code>提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为Rust项目的管理提供尽可能完整的手段，同时，与Rust语言及其编译器rustc紧密结合，可以说用了后就忘不掉，如同那种初恋般的触电感觉。</p>
<h2 id="创建一个你好世界项目"><a class="header" href="#创建一个你好世界项目">创建一个&quot;你好,世界&quot;项目</a></h2>
<p>又见&quot;你好,世界&quot;，肯定有读者在批评了：你就不能优点创意吗？&quot;世界,你好&quot;不行吗？你是读者，你说了算，好的，那我们来创建一个&quot;世界，你好&quot;。</p>
<p>上门提到过，Rust语言的包管理工具名称叫<code>cargo</code>，好在，我们无需手动安装，在之前安装Rust的时候，就一起安装了，如果你在终端无法使用这个命令，考虑一下<code>环境变量</code>是否正确的设置，你需要把<code>cargo</code>可执行文件所在的目录添加到环境变量中。</p>
<p>在终端输入:</p>
<pre><code class="language-console">$ cargo new world_hello
</code></pre>
<p>上面的命令使用<code>cargo new</code>创建了一个项目，项目名是<code>world_hello</code>(向读者势力低头的项目名称，泪奔)，这个项目的结构和配置文件都是由<code>cargo</code>生成，这种结构和配置文件意味着<strong>该项目被cargo所管理</strong>，早期的cargo在创建项目时，必须添加<code>--bin</code>的参数，如下所示：</p>
<pre><code class="language-console">$ cargo new world_hello --bin
</code></pre>
<p>现在的版本，已经无需这个参数，<code>cargo</code>默认就为我们创建<code>bin</code>类型的项目，顺便说一句，rust项目主要分为两个类型：bin和lib，前者是一个可以运行的项目，后者是一个依赖库项目。</p>
<p>创建的项目结构：</p>
<pre><code class="language-console">.
├── .git
├── .gitignore
├── Cargo.toml
└── src
    └── main.rs

</code></pre>
<p>是的，连git都给你创建了，比小棉袄还体贴。</p>
<h2 id="运行该项目"><a class="header" href="#运行该项目">运行该项目</a></h2>
<p>有两种方式可以运行我们的项目，先来看看第一种</p>
<h4 id="cargo-run"><a class="header" href="#cargo-run">cargo run</a></h4>
<p>真的很简单，我就不废话了，在项目根目录下运行：</p>
<pre><code class="language-console">$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/world_hello`
Hello, world!
</code></pre>
<p>好了，你已经看到程序的输出: <code>&quot;Hello, world&quot;</code>, 可能有读者不愿意了，说好了&quot;世界，你好&quot;呢? 别急，在下一节，我们再对代码进行修改。</p>
<p>在上面的过程中，<code>cargo run</code>会对项目进行编译，然后再运行项目，如同我们下面将做的</p>
<h4 id="手动编译和运行项目"><a class="header" href="#手动编译和运行项目">手动编译和运行项目</a></h4>
<p>先来编译项目:</p>
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</code></pre>
<p>接着手动运行：</p>
<pre><code class="language-console">$ ./target/debug/world_hello 
Hello, world!
</code></pre>
<p>很简单对吧？细心的读者可能已经发现，在调用的时候，路径<code>./target/debug/world_hello</code>中有一个明晃晃的<code>debug</code>字段，没错我们运行的是<code>debug模式</code>，在这种模式下，<strong>代码的编译速度会非常快</strong>，但是<strong>运行速度就比较慢</strong>了，原因在于这个模式下，Rust编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。</p>
<p>那如果我们想要高性能的代码怎么办？可以添加<code>--release</code>来编译：</p>
<ul>
<li><code>cargo run --release</code></li>
<li><code>cargo build --release</code>
如果你用的第二个命令，就要换一个路径来运行程序</li>
</ul>
<pre><code class="language-console">$ ./target/release/world_hello 
Hello, world!
</code></pre>
<p>当项目大了后，<code>cargo run</code>和<code>cargo build</code>不可避免的会变慢，那么有没有更快的方式来验证代码的正确性呢？大杀器来了，接着！</p>
<h2 id="cargo-check"><a class="header" href="#cargo-check">cargo check</a></h2>
<p><code>cargo check</code>是我们在代码开发过程中用的最多的命令，它的作用很简单：快速的检查一下代码能否编译通过，所以速度会非常快，帮助我们节省大量的编译时间(毕竟Rust不是Go，需要做很多复杂的编译优化和语言特性解析，所以编译速度比Go慢了不少)。</p>
<pre><code class="language-console">$ cargo check
    Checking world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
</code></pre>
<h2 id="cargotoml-和-cargolock"><a class="header" href="#cargotoml-和-cargolock">cargo.toml 和 cargo.lock</a></h2>
<p><code>cargo.toml</code>和<code>cargo.lock</code>是cargo项目代码管理的核心文件，cargo工具的所有活动均基于这两个文件。</p>
<p><code>cargo.toml</code>是cargo特有的项目数据描述文件，存储了项目的所有元配置信息，如果rust开发者希望rust项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建<code>cargo.toml</code>。</p>
<p><code>cargo.lock</code>文件是cargo工具根据同一项目的toml文件生成的项目依赖详细清单文件，所以我们一般不用不管它，只需要对着cargo.toml文件撸就行了。</p>
<blockquote>
<p>什么情况下该把<code>cargo.lock</code>上传到git仓库里？很简单，当你的项目是一个可运行的程序时，就上传<code>cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到<code>.gitignore</code>中</p>
</blockquote>
<p>现在可以打开&quot;世界，你好&quot;项目下的<code>cargo.toml</code>文件，我们来简单介绍下：</p>
<h4 id="package配置段落"><a class="header" href="#package配置段落">package配置段落</a></h4>
<p><code>package</code>中配置了我们项目的一些描述信息，典型的如下：</p>
<pre><code class="language-toml">[package]
name = &quot;world_hello&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p><code>name</code>字段定义了项目名称，<code>version</code>字段定义了项目的当前版本，新项目默认是<code>0.1.0</code>，<code>edition</code>字段定义了我们使用的Rust大版本，因为本书很新(不仅仅是现在新，未来也将及时修订，跟得上Rust最新大版本)，所以我们使用的是<code>Rust edition 2021</code>大版本，现有的很多项目还在使用<code>Rust edition 2018</code>，具体参见<a href="first-try/../appendix/rust-version.html">Rust版本详解</a>.</p>
<h4 id="定义项目依赖"><a class="header" href="#定义项目依赖">定义项目依赖</a></h4>
<p>使用cargo工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。这也是使用cargo对Rust项目进行管理的重要目标之一。在cargo的toml文件描述中，主要通过各种依赖段落来描述该项目的各种依赖项。<code>cargo.toml</code>中常用的依赖段落包括一下几种：</p>
<ul>
<li>基于rust官方仓库crates.io，通过版本说明来描述</li>
<li>基于项目源代码的git仓库地址，通过URL来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类Unix模式的路径来描述 </li>
</ul>
<p>这三种形式具体写法如下：</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.3&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<p>相信聪明的读者已经能看懂该怎么引入外部依赖库，我们就不逐行解释了。</p>
<p>详细的说明参见此章:<a href="first-try/../cargo/dependency.html">Cargo依赖管理</a>，但是不建议新手现在去看，等学习后面，自然就能看到。</p>
<h2 id="基于cargo的项目组织结构"><a class="header" href="#基于cargo的项目组织结构">基于cargo的项目组织结构</a></h2>
<p>在上文我们已经看到了cargo默认生成的项目结构，但是真实的项目还有所不同，但是在目前的学习阶段，我们还不需要关注这个，感兴趣的同学可以移步此处：<a href="first-try/../cargo/layout.html">Cargo项目结构</a></p>
<p>至此，大家对Rust项目的创建和管理已经有了初步的了解，让我们来完善刚才的<code>&quot;世界,你好&quot;</code>项目吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不仅仅是hello-world"><a class="header" href="#不仅仅是hello-world">不仅仅是Hello world</a></h1>
<p>几乎所有教程中安装的最后一个环节都是<code>hello world</code>，我们也不能免俗，但是在<code>hello world</code>之后，还有一个相亲，阿呸，Rust初印象环节，希望大家喜欢。</p>
<h2 id="多国语言的世界你好"><a class="header" href="#多国语言的世界你好">多国语言的&quot;世界，你好&quot;</a></h2>
<p>还记得我们之前讲到的<a href="first-try/./editor.html">VScode</a> IDE和通过Cargo创建的<a href="first-try/./cargo.html">世界，你好</a>工程吧? </p>
<p>现在使用VScode打开我们在<a href="first-try/./cargo.html">上一节</a>中创建的<code>world_hello</code>工程, 然后打开main.rs文件，这是当前Rust工程的入口文件，和其它语言没有区别。</p>
<p>将该文件内容修改为：</p>
<pre><pre class="playground"><code class="language-rust">fn greet_world() {
     let southern_germany = &quot;Grüß Gott!&quot;;
     let chinese = &quot;世界，你好&quot;;
     let english = &quot;World, hello&quot;;
     let regions = [southern_germany, chinese, english];
     for region in regions.iter() {
             println!(&quot;{}&quot;, &amp;region);
     }
 }
 
 fn main() {
     greet_world();
 }
</code></pre></pre>
<p>然后打开终端，进入<code>world_hello</code>工程根目录，运行该程序(你也可以在VScode中打开终端,方法是点击左下角的错误和警告图标)，可以看到来自世界各地的热情招呼：</p>
<pre><code class="language-console">$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
     Running `target/debug/world_hello`
Grüß Gott!
世界，你好
World, hello
sunfei@sunfeideMa
</code></pre>
<p>花点时间来看看上面的代码，首先，Rust原生支持UTF-8编码的字符串，这意味着你可以很容易的使用其它语言作为字符串内容。</p>
<p>其次，关注下<code>println</code>后面的<code>!</code>，如果你有Ruby编程经验，那么你可能会认为这是解构操作符，但是在Rust中，这是<code>宏</code>操作符，你目前可以认为宏是一种特殊类型函数。对于<code>println</code>来说，我们没有使用其它语言惯用的<code>%s</code>,<code>%d</code>来做输出占位符，而是使用{}，因为Rust在底层帮我们做了大量工作，会自动识别输出数据的类型，例如当前例子，会识别为<code>string</code>类型。</p>
<p>最后，和其它语言不同，rust的集合类型不能直接进行循环，需要变成迭代器(这里是通过<code>.iter()</code>方法)后，才能用于迭代循环，在目前来看，你会觉得这一点好像挺麻烦，不急，以后就知道这么做的好处所在.</p>
<p>至于函数声明、调用、数组的使用，和其它语言没什么区别，so easy!</p>
<h2 id="rust语言初印象"><a class="header" href="#rust语言初印象">Rust语言初印象</a></h2>
<p>Rust这门语言对于Haskell和Java开发来说，会觉得很熟悉，因为它们在高阶表达方面都很优秀，简而言之，可以很简洁的写出原本需要一大堆代码才能表达的含义，但是Rust又有所不同：它的性能是底层语言级别的性能，可以跟C/C++相媲美。</p>
<p>在上一节，咱们学习了非常简单的Rust入门代码，现在来点复杂的，然后说说你对Rust的初印象。</p>
<p>下面的例子是关于基础文本处理：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let penguin_data = &quot;\
   common name,length (cm)
   Little penguin,33
   Yellow-eyed penguin,65
   Fiordland penguin,60
   Invalid,data
   &quot;;
 
   let records = penguin_data.lines();
 
   for (i, record) in records.enumerate() {
     if i == 0 || record.trim().len() == 0 {
       continue;
     }
     
     // 声明一个fields变量，类型是Vec
     // Vec是vector的缩写，是一个可伸缩的集合类型，可以认为是一个动态数组
     // &lt;_&gt;表示Vec中的元素类型由编译器自行推断，在很多场景下，都会帮我们省却不少功夫
     let fields: Vec&lt;_&gt; = record
       .split(',')
       .map(|field| field.trim())
       .collect();
     if cfg!(debug_assertions) {
         // 输出到标准错误输出
       eprintln!(&quot;debug: {:?} -&gt; {:?}&quot;,
              record, fields);
     }
 
     let name = fields[0];
     // 1. 尝试把fields[1]的值转换为f32类型的浮点数，如果成功，则把f32值赋给length变量
     // 2. if let是一个匹配表达式，用来从=右边的结果中，匹配出length的值:
     // 当=右边的表达式执行成功，则会返回一个Ok(f32)的类型，若失败，则会返回一个Err(e)类型，if let的作用就是仅匹配Ok也就是成功的情
     // 况,如果是错误，就直接忽略，同时if let还会做一次解构匹配，通过Ok(length)去匹配右边的Ok(f32)，最终把相应的f32值赋给length
     // 3. 当然你也可以忽视成功的情况，用if let Err(e) = fields[1].parse::&lt;f32&gt;() {...}匹配出错误，然后打印出来，但是没啥卵用
     if let Ok(length) = fields[1].parse::&lt;f32&gt;() {
         // 输出到标准输出
         println!(&quot;{}, {}cm&quot;, name, length);
     }
   }
 }
</code></pre></pre>
<p>上面代码中值得注意的Rust特性有：</p>
<ul>
<li>控制流：<code>for</code>和<code>continue</code>在一起，实现的循环</li>
<li>方法语法：由于Rust没有继承，因此Rust不是传统意义上的面向对象语言，但是它却从OO语言那里偷师了方法的使用<code>record.trim()</code>,<code>record.split(',')</code>等</li>
<li>高阶函数编程： 函数可以作为参数也能作为返回值，例如<code>.map(|field| field.trim())</code>, 这里<code>map</code>使用闭包函数作为参数，也可以称呼为<code>匿名函数</code>、<code>lambda函数</code></li>
<li>类型标注: <code>if let Ok(length) = fields[1].parse::&lt;f32&gt;()</code>, 通过<code>::&lt;f32&gt;</code>的使用，告诉编译器<code>length</code>是一个<code>f32</code>类型的浮点数，这种类型标注不是很常用，但是在编译器无法推断出你的数据类型时，就很有用了</li>
<li>条件编译: <code>if cfg!(debug_assertions)</code>，说明下面的输出打印只在<code>debug</code>模式下生效</li>
<li>隐式返回：Rust提供了<code>return</code>关键字用于函数返回，但是在很多时候，我们可以省略它。因为Rust是<a href="first-try/../basic/statement-expression.html"><strong>基于表达式的语言</strong></a></li>
</ul>
<p>在终端中运行上述代码时，你会看到很多<code>debug: ...</code>的输出，你也已经了解，这是<code>条件编译</code>, 那么该怎么消除掉这些输出呢？</p>
<p>读者大大肯定都很聪明，已经想到了：是的，在<a href="first-try/./cargo.html#%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE">认识Cargo</a>中，曾经介绍过<code>--relese</code>参数，因为cargo run默认是运行的debug模式，如果想要消灭那些<code>debug:</code>输出，我们需要更改为其它模式，其中最常用的模式就是<code>--release</code>也就是生产发布的模式。</p>
<p>具体运行代码就不给了，留给大家作为一个小练习，建议亲自动手尝试下。</p>
<p>至此，Rust安装入门就已经结束，相信看到这里，你已经发现了本书与其它书的区别，其中最大的区别就是：<strong>这本书就像优秀的国外课本一样，由浅入深的在带领大家学习Rust，而不是简单的复述一些语言的概念</strong>，你可以回忆一下国内的线性代数等计算机教材，都是可以做为对照的反例(当然，不是说这些教材不优秀，只是这些教材需要优秀的老师支撑，而我们并没有)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust基本概念"><a class="header" href="#rust基本概念">Rust基本概念</a></h1>
<p>从现在开始，你已经正式踏入了Rust大陆，这篇广袤而神秘的世界，在这个世界中，你将接触到很多之前你都没有听过的概念：</p>
<ul>
<li>所有权、借用、生命周期</li>
<li>宏编程</li>
<li>模式匹配</li>
</ul>
<p>类似的还有很多，不过不用怕，一方面，这本书会带你彻底探索这个神秘的大陆，另一方面，我们也有一个非常友善的社区，在里面你可以提问也可以分享自己的所学所思: <a href="https://community.college.rs">社区网址</a>.</p>
<p>本章主要介绍Rust的基础语法、数据类型、项目结构等，学完本章，你将对Rust代码有一个清晰、完整的认识。</p>
<p>在基本概念方面，Rust和其它语言并没有大的区别，它拥有变量、数据、函数等等。</p>
<p>通过下面的代码我们来简单浏览下Rust的语法:</p>
<pre><pre class="playground"><code class="language-rust">// rust程序入口函数，跟其它语言一样，都是main，该函数目前无返回值
fn main() {
   // 使用let来声明变量，进行绑定，a是不可变的
   // 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
   // 语句的末尾必须以分号结尾
   let a = 10;
   // 主动指定b的类型为i32
   let b: i32 = 20;
   // 这里有两点值得注意：
   // 1. 可以在数值中带上类型:30i32表示数值是30，类型是i32
   // 2. c是可变的，mut是mutable的缩写
   let mut c = 30i32;
   // 还能在数值和类型中间添加一个下划线，让可读性更好
   let d = 30_i32;
   // 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数
   let e = add(add(a, b), add(c, d));
    
   // println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块
   // 该函数将指定的格式化字符串输出到标准输出中(控制台)
   // {}是占位符，在具体执行过程中，会把a的值代入进来
   println!(&quot;( a + b ) + ( c + d ) = {}&quot;, e);
 }
 
 // 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和
 fn add(i: i32, j: i32) -&gt; i32 {
   // 返回相加值，这里可以省略return
   i + j
 }
</code></pre></pre>
<blockquote>
<p>注意
在上面的<code>add</code>函数中，不要为<code>i+j</code>添加<code>;</code>，这会改变语法导致函数返回<code>()</code>而不是<code>i32</code>,具体参见<a href="basic/./statement-expression.html">语句和表达式</a></p>
</blockquote>
<p>还有几点可以留意下:</p>
<ul>
<li>字符串使用双引号<code>&quot;&quot;</code>而不是单引号<code>''</code>.Rust中单引号是留给单个字符类型(<code>char</code>)使用的</li>
<li>Rust使用<code>{}</code>来作为占位符，其它语言可能使用的是<code>%s</code>，<code>%d</code>,<code>%p</code>等，因为<code>println!</code>会自动推导出具体的类型, 无需手动指定</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量绑定与解构"><a class="header" href="#变量绑定与解构">变量绑定与解构</a></h1>
<blockquote>
<p>本节在内容上部分参考了<a href="https://doc.rust-lang.org/stable/book/">Rust Book</a></p>
</blockquote>
<p>鉴于本书的<a href="basic/../intro.html">目标读者</a>已经熟练掌握其它任意一门编程语言，因此这里就不再对何为变量进行赘述，让我们开门见山来谈谈，为何Rust选择了手动设定变量可变性。</p>
<h2 id="为何要手动设置变量的可变性"><a class="header" href="#为何要手动设置变量的可变性">为何要手动设置变量的可变性？</a></h2>
<p>在其它大多数语言中，变量一旦创建，要么是可变的，要么是不可变的(ClosureScript),前者为编程提供了灵活性，后者为编程提供了安全性，而Rust选择了两者我都要，既要灵活性又要安全性。</p>
<p>能想要学习Rust，说明我们的读者都是相当有水平的程序员了，你们应该能理解一切选择都是权衡，那么两者都要的权衡是什么呢？这就是Rust开发团队为我们做出的贡献，两者都要意味着底层代码的实现复杂度大幅提升，Respect to The Rust Team!</p>
<p>除了以上两个优点，还有一个很大的优点，那就是运行性能上的提升，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的runtime检查。</p>
<h2 id="变量命名"><a class="header" href="#变量命名">变量命名</a></h2>
<p>在命名方面，和其它语言没有区别，不过当你给变量命名时，需要遵循<a href="basic/../style-guide/naming.html">Rust命名规范</a>。</p>
<blockquote>
<p>Rust语言有一些<strong>关键字</strong>（<em>keywords</em>），和其他语言一样，这些关键字都是被保留给Rust语言使用的，因此，这些关键字不能被用作变量或函数的名称。 在<a href="basic/../appendix/keywords">附录 A</a> 中可找到关键字列表。</p>
</blockquote>
<h2 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h2>
<p>在其它语言中，我们用<code>var a = &quot;hello world&quot;</code>的方式给a赋值，也就是把等式右边的<code>&quot;hello world</code>&quot;字符串赋值给变量<code>a</code>，而在Rust中，我们这样写：<code>let a = &quot;hello world&quot;</code>, 同时给这个过程起了另一个名字:<strong>变量绑定</strong>。</p>
<p>为何不用赋值而用绑定呢(其实你也可以称之为赋值，但是绑定的含义更清晰准确)？这里就涉及Rust最核心的原则-<strong>所有权</strong>，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人(聪明的读者应该能猜到，在这种情况下，该对象之前的主人就会丧失对该对象的所有权)，像极了我们的现实世界，不是吗？</p>
<p>至于为何要采用所有权这种复杂的东东，先别急，等讲<a href="basic/../core/intro.html">Rust核心概念</a>时，我们会为你详细道来。</p>
<h2 id="变量可变性"><a class="header" href="#变量可变性">变量可变性</a></h2>
<p>Rust的变量在默认情况下是<strong>不可变的</strong>。在上文提到过，这是Rust团队为我们精心设计的语言特性之一，这样可以让我们编写更安全、更高性能的代码。当然你可以通过<code>mut</code>关键字让变量变为<strong>可变的</strong>，以实现更加灵活的设计。</p>
<p>当变量不可变时，这意味着一旦一个值绑定到一个变量<code>a</code>后，就不能再更改<code>a</code>的值了。为了说明，在我们的工程目录下使用 <code>cargo new variables</code>来创建一个名为 <em>variables</em> 的新项目。</p>
<p>然后在新建的 <em>variables</em> 目录下，打开 <em>src/main.rs</em> 并将代码替换为下面还未能通过编译的代码：</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>保存文件，并使用 <code>cargo run</code>运行程序或者。你将会收到一条错误消息，输出如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
</code></pre>
<p>具体的错误原因是 <code>cannot assign twice to immutable variable x</code>（对不可变的变量无法进行二次再赋值），因为我们尝试给不可变的 <code>x</code> 变量赋予第二个值。</p>
<p>这种错误是为了避免无法预期的错误发生在我们的变量上：一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。</p>
<p>这种规则让我们的代码变得非常清晰，只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。</p>
<p>但是可变性也非常重要，否则我们就要像ClosureScript中那样，每次要改变，就是重新生成一个对象，在拥有大量对象的场景，性能会变得非常低下，内存拷贝的成本异常的高。</p>
<p>在Rust中，可变性很简单，只要在变量名前加一个<code>mut</code>即可, 而且这种显式的声明方式还会给后来人传达这样的信息：嗯，这个变量在后面代码部分会发生改变。</p>
<p>为了让变量可变(挺拗口的),将 <em>src/main.rs</em> 改为以下内容：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>运行程序将得到下面结果：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>一切抉择都是权衡，使用可变还是不可变，更多的还是取决于你的选择，例如不可变可以带来安全性，但是丧失了灵活性和性能(如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配)。而可变变量最大的好处就是使用上的灵活和性能上的提升。</p>
<p>例如，在使用大型数据结构或者热点代码路径(被大量频繁调用)的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。</p>
<h3 id="变量解构"><a class="header" href="#变量解构">变量解构</a></h3>
<p>let表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!(&quot;a = {:?}, b = {:?}&quot;, a, b);

    b = true;
    assert_eq!(a, b);
}
</code></pre></pre>
<h3 id="变量和常量之间的差异"><a class="header" href="#变量和常量之间的差异">变量和常量之间的差异</a></h3>
<p>变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：<strong>常量</strong>（<em>constant</em>）。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异。</p>
<p>首先，常量不允许使用 <code>mut</code>。<strong>常量不仅仅默认不可变，而且自始至终不可变</strong>。</p>
<p>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明，并且值的类型<strong>必须</strong>标注。我们将在下一节<a href="basic/./type.html">数据类型</a>中介绍，因此现在暂时无需关心细节。</p>
<p>最后一个不同点是常量只能设置为常量表达式，而不能是函数调用的结果或是只能在运行时计算得到的值，例如你可以这样来声明常量：</p>
<p>下面是一个常量声明的例子，其常量名为 <code>MAX_POINTS</code>，值设置为 100,000。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<p>常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家赚取的最大点数或光速。</p>
<blockquote>
<p>在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可。</p>
</blockquote>
<h3 id="变量遮蔽shadowing"><a class="header" href="#变量遮蔽shadowing">变量遮蔽(shadowing)</a></h3>
<p>Rust允许声明相同的变量名,在后面声明的变量会遮蔽掉前面声明的, 如下所示：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {}&quot;, x);
    }

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>这个程序首先将数值 <code>5</code> 绑定到 <code>x</code>，然后通过重复使用 <code>let x =</code> 来遮蔽之前的 <code>x</code>，并取原来的值加上 <code>1</code>，所以 <code>x</code> 的值变成了 <code>6</code>。第三个 <code>let</code> 语句同样遮蔽前面的 <code>x</code>，取之前的值并乘上 <code>2</code>，得到的 <code>x</code> 最终值为 <code>12</code>。当运行此程序，将输出以下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
   ...
The value of x is: 12
</code></pre>
<p>这和<code>mut</code>变量的使用是不同的，第二个let生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配
，而<code>mut</code>声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要好很多。</p>
<p>变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量(在被遮蔽后，无法再访问到之前的同名变量)，就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<p>例如，假设我们程序要求用户输入空格字符来显示他们想要的空格数目，但我们实际上想要将该输入存储为一个数字：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // 字符串类型
    let spaces = &quot;   &quot;;
    // usize数值类型
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>这种结构是允许的，因为第一个 <code>spaces</code> 变量是一个字符串类型，第二个 <code>spaces</code> 变量是一个全新的变量且和第第一个具有相同的变量名，且是一个数值类型。所以变量遮蔽可以让我们就不必给出不同的名称，如 <code>spaces_str</code> 和 <code>spaces_num</code>；相反我们可以重复使用更简单的 <code>spaces</code> 变量名。然而，如果我们对此尝试使用 <code>mut</code>，如下所示，我们将得到一个编译期错误：</p>
<pre><pre class="playground"><code class="language-rust ">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>运行一下</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error
</code></pre>
<p>该错误标明，我们试图把一个<code>usize</code>类型的数值赋值为一个字符串变量。</p>
<p>至此，关于变量的内容你已经彻底掌握了，下面来学习下Rust的数据类型。Rust每个值都有其确切的数据类型, 总的来说可以分为两类：基本类型和复合类型, 先来看看基本类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h1>
<p>基本数据类型在Rust中是最最常见的数据类型，基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，基本类型由以下组成：</p>
<ul>
<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li>
<li>字符串：字符串字面量、字符串切片&amp;str和堆分配字符串String</li>
<li>布尔类型： <code>true</code>和<code>false</code></li>
<li>字符类型: 表示单个Unicode字符，存储为4个字节</li>
<li>元类型: 即<code>()</code>，其唯一的值也是<code>()</code></li>
</ul>
<h2 id="类型推导与标注"><a class="header" href="#类型推导与标注">类型推导与标注</a></h2>
<p>与python、js等动态语言不同，Rust是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的数据类型，但这不意味着你需要为你的每个变量指定类型，因为<strong>Rust编译器很聪明，它可以根据变量的值和使用方式来自动推导出变量的类型</strong>，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要我们手动去给予一个类型标注，关于这一点在<a href="basic/base-type/../first-try/hello-world.html#Rust%E8%AF%AD%E8%A8%80%E5%88%9D%E5%8D%B0%E8%B1%A1">Rust语言初印象</a>中有过展示.</p>
<p>再比如以下代码(引用自Rust官方编程那本书):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>如果这里不添加类型标注，则编译器会报错：</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type
</code></pre>
<p>意味着，我们需要提供给编译器更多的信息，例如给<code>guess</code>变量一个显示的类型标注: <code>let guess:i32 = ...</code> 或者<code>&quot;42&quot;.parse::&lt;i32&gt;()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h1>
<p>计算机和数值关联在一起的时间，远比你想象的要长，因此数值类型可以说是有计算机以来就有的类型，下面内容将深入讨论Rust的数值类型以及相关的运算符。</p>
<h2 id="整数和浮点数"><a class="header" href="#整数和浮点数">整数和浮点数</a></h2>
<p>Rust使用一个相对传统的语法来创建整数(<code>1</code>,<code>2</code>,...)和浮点数(<code>1.0</code>,<code>1.1</code>,...)。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。</p>
<blockquote>
<p>不仅仅是数值类型，Rust也允许在复杂类型上定义运算符，例如在自定义类型上定义<code>+</code>运算符，这种行为被称为运算符重载, Rust具体支持的可重载运算符见<a href="basic/base-type/../../appendix/operators.html#%E8%BF%90%E7%AE%97%E7%AC%A6">这里</a></p>
</blockquote>
<h4 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h4>
<p><strong>整数</strong>是没有是没有小数部分的数字。在之前，我们使用过<code>i32</code>类型, 表示有符号的32位整数（<code>i</code> 是英文单词 <em>integer</em> 的首字母，与之相反的是 <code>u</code>，代表无符号 <code>unsigned</code> 类型）。下表显示了 Rust 中的内置的整数类型, 在有符号和和无符号的列中（例如 <em>i16</em>）的每个定义形式都可用于声明整数类型。</p>
<p><span class="caption">Rust 中的整数类型</span></p>
<table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody>
<tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-位</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>类型定义的形式统一为：有无符号 + 类型大小(位数)。<strong>无符号数</strong>表示数字只能取正数，而<strong>有符号</strong>则表示数字即可以取正数又可以取负数。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码</a>形式存储。</p>
<p>每个有符号类型规定的数字范围是  -(2<sup>n - 1</sup>) ~ 2<sup>n -
1</sup> - 1，其中 <code>n</code> 是该定义形式的位长度。所以 <code>i8</code> 可存储数字范围是 -(2<sup>7</sup>) ~ 2<sup>7</sup> - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2<sup>n</sup> - 1，所以 <code>u8</code> 能够存储的数字为 0 ~ 2<sup>8</sup> - 1，即 0 ~ 255。</p>
<p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机cpu类型： 若cpu是32位的，则这两个类型是32位的，同理，若cpu是64位，那么它们则是64位64位.</p>
<p>整型的字面量可以可以写成下表 3-2 中任意一种。注意，除了字节字面量之外的所有的数字字面量都允许使用类型后缀，例如 <code>57u8</code>，还有可以使用 <code>_</code> 作为可视分隔符，如 <code>1_000</code>。</p>
<p><span class="caption">表 3-2: Rust 的整型字面量</span></p>
<table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody>
<tr><td>十进制</td><td><code>98_222</code></td></tr>
<tr><td>十六进制</td><td><code>0xff</code></td></tr>
<tr><td>八进制</td><td><code>0o77</code></td></tr>
<tr><td>二进制</td><td><code>0b1111_0000</code></td></tr>
<tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>那么该使用哪种类型的整型呢？如果不确定，Rust 的默认值通常是个不错的选择，整型默认是 <code>i32</code>：这通常是最快的，即便在 64 位系统上也是。<code>isize</code> 和 <code>usize</code> 的主要应用场景是用作某些集合的索引。</p>
<blockquote>
<h5 id="整型溢出"><a class="header" href="#整型溢出">整型溢出</a></h5>
<p>比方说有一个 <code>u8</code> ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生<strong>整型溢出</strong>。关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 会检查整型溢出若存在这些问题则使程序在编译时 <em>panic</em>。Rust 使用这个术语来表明程序因错误而退出。 <a href="basic/base-type/../../errors/panic.html">该章节</a>会详细介绍 panic。</p>
<p>在当使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。相反当检测到整型溢出时，Rust 会进行一种被称为二进制补码的方式进行（<em>two’s complement wrapping</em>）操作。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖整型溢出包裹的行为不是一种正确的做法。</p>
<p>要显式处理溢出的可能性，可以使用标准库针对原始数字类型提供的以下的一系列方法：</p>
<ul>
<li>使用 <code>wrapping_*</code> 方法在所有模式下进行包裹，例如 <code>wrapping_add</code></li>
<li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li>
<li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li>
</ul>
</blockquote>
<h4 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h4>
<p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，因为在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮点数根据 IEEE-754 标准表示。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度。</p>
<h4 id="数字运算"><a class="header" href="#数字运算">数字运算</a></h4>
<p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码演示了各使用一条 <code>let</code> 语句来说明相应运算的用法：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 求余
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。<a href="basic/base-type/../../appendix/operators.html">附录</a>中给出了 Rust 提供的所有运算符的列表。</p>
<p>再来看一个综合性的示例:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   // 编译器会进行自动推导，给予twenty i32的类型
   let twenty = 20;
   // 类型标注
   let twenty_one: i32 = 21;
   // 通过类型后缀的方式进行类型标注：22是i32类型
   let twenty_two = 22i32;
    
    // 只有同样类型，才能运算
   let addition = twenty + twenty_one + twenty_two;
   println!(&quot;{} + {} + {} = {}&quot;, twenty, twenty_one, twenty_two, addition);
    
    // 对于较长的数字，可以用_进行分割，提升可读性
   let one_million: i64 = 1_000_000;
   println!(&quot;{}&quot;, one_million.pow(2));
    
   // 定义一个f32数组，其中42.0会自动被推导为f32类型
   let forty_twos = [
     42.0,
     42f32,
     42.0_f32,
   ];
  
  // 打印数组中第一个值，其中控制小数位为2位
  println!(&quot;{:02}&quot;, forty_twos[0]);
 }
</code></pre></pre>
<h4 id="浮点数陷阱"><a class="header" href="#浮点数陷阱">浮点数陷阱</a></h4>
<p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<ol>
<li>
<p><strong>浮点数往往是你想要数字的近似表达</strong>
浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如0.1在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</p>
</li>
<li>
<p><strong>浮点数在某些特性上是反直觉的</strong>
例如你觉得浮点数可以进行比较，对吧？是的，它们确实可以使用<code>&gt;</code>,<code>&gt;=</code>等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为<code>f32</code>,<code>f64</code>上的比较运算实现的是<code>std::cmp::PartialEq</code><a href="basic/base-type/../../advance/trait.html">特征</a>, 但是并没有实现<code>std::cmp::Eq</code>特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</p>
</li>
</ol>
<p>Rust的HashMap数据结构，是一个KV类型的hash map实现，它对于K没有特定类型的限制，但是要求能用作K的类型必须实现了<code>std::cmp::Eq</code>特征，因为这意味着你无法使用浮点数作为HashMap的Key，来存储键值对，但是作为对比，Rust的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为HashMap的Key。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<ul>
<li>避免在浮点数上测试相等性</li>
<li>当结果在数学上可能存在未定义时，需要格外的小心</li>
</ul>
<p>来看个小例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
</code></pre></pre>
<p>你可能以为，这段代码没啥问题吧，实际上它会panic(程序崩溃，抛出异常)，因为二进制精度问题，导致了0.1 + 0.2并不严格等于0.3，它们可能在小数点N位后存在误差。</p>
<p>那如果非要进行比较呢？可以考虑用这种方式<code>(0.1 + 0.2 - 0.3).abs() &lt; 0.00001</code>,具体小于多少，取决于你对精度的需求.</p>
<p>讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
     let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
     let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);
 
     println!(&quot;abc (f32)&quot;);
     println!(&quot;   0.1 + 0.2: {:x}&quot;, (abc.0 + abc.1).to_bits());
     println!(&quot;         0.3: {:x}&quot;, (abc.2).to_bits());
     println!();
 
     println!(&quot;xyz (f64)&quot;);
     println!(&quot;   0.1 + 0.2: {:x}&quot;, (xyz.0 + xyz.1).to_bits());
     println!(&quot;         0.3: {:x}&quot;, (xyz.2).to_bits());
     println!();
 
     assert!(abc.0 + abc.1 == abc.2);
     assert!(xyz.0 + xyz.1 == xyz.2);
 }
</code></pre></pre>
<p>运行该程序，输出如下:</p>
<pre><code class="language-console">abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a
 
xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333
 
thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
</code></pre>
<p>仔细看，对<code>f32</code>类型做加法时，<code>0.1+0.2</code>的结果是<code>3e99999a</code>，0.3也是<code>3e99999a</code>，因此<code>f32</code>下的<code>0.1+0.2=0.3</code>通过测试，但是到了<code>f64</code>类型时，结果就不一样了，因为f64精度高很多，因此在小数点非常后面发生了一点微小的变化，<code>0.1+0.2</code>以<code>4</code>结尾，但是0.3以<code>3</code>结尾，因此<code>f64</code>下的测试失败了，并且抛出了异常。</p>
<p>是不是<strong>blow your mind away</strong>? 没关系，在本书的后续章节中类似的直击灵魂的代码还很多，这就是我们敢号称<code>Rust语言圣经</code>的勇气!</p>
<h4 id="nan"><a class="header" href="#nan">NaN</a></h4>
<p>对于数学上未定义的结果，例如对负数取平方根<code>-42.1.sqrt()</code>，会产生一个特殊的结果：Rust的浮点数类型使用NaN(not a number)来处理这些情况。</p>
<p><strong>所有跟<code>NaN</code>交互的操作，都会返回一个<code>NaN</code></strong>，而且<code>NaN</code>不能用来比较，下面的代码会崩溃:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
</code></pre></pre>
<p>出于防御性编程的考虑，可以使用<code>is_nan()</code>等方法，可以用来判断一个数值是否是<code>NaN</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!(&quot;未定义的数学行为&quot;)
    }
}
</code></pre></pre>
<h2 id="序列range"><a class="header" href="#序列range">序列(Range)</a></h2>
<p>Rust提供了一个非常遍历的方式，让我们能生成连续的数值，例如<code>1..5</code>，生成从1到4的连续数字，不包含5; <code>1..5</code>，生成从1到5的连续数字,包含5，它的用户很简单，常常用于循环中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  for i in 1..=5 {
        println!(&quot;{}&quot;,i);
    }
<span class="boring">}
</span></code></pre></pre>
<p>最终程序输出:</p>
<pre><code class="language-console">1
2
3
4
5
</code></pre>
<h2 id="有理数和复数"><a class="header" href="#有理数和复数">有理数和复数</a></h2>
<p>Rust的标准库相比其它语言，对于准入的门槛较高，因此有理数和复数并未包含在标准库中:</p>
<ul>
<li>有理数和复数对应的数据库</li>
<li>任意大小的整数和任意精度的浮点数</li>
<li>固定精度的十进制小数，常用于货币相关的场景</li>
</ul>
<p>好在社区已经开发出高质量的Rust数值库：<a href="https://crates.io/crates/num">num</a>.</p>
<p>按照以下步骤来引入<code>num</code>库：</p>
<ol>
<li>创建新工程<code>cargo new complex-num &amp;&amp; cd complex-num</code></li>
<li>在<code>Cargo.toml</code>中的<code>[dependencies]</code>下添加一行<code>num = 0.4</code></li>
<li>将<code>src/main.rs</code>文件中的<code>main</code>函数替换为下面的代码</li>
<li>运行<code>cargo run</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">use num::complex::Complex;
 
 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;
 
   println!(&quot;{} + {}i&quot;, result.re, result.im)
 }
</code></pre></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>之前提到了过Rust的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点:</p>
<ul>
<li><strong>Rust拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li>
<li><strong>类型转换必须是显式的</strong>. Rust永远也不会偷偷把你的16bit整数转换成32bit整数</li>
<li><strong>Rust的数值上可以使用方法</strong>. 例如你可以用以下方法来将24.5取整: <code>13.14_f32.round()</code>, 在这里我们使用了类型后缀，因为编译器需要知道<code>13.14</code>的具体类型</li>
</ul>
<p>数值类型的讲解已经基本结束，接下来来看看字符串。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符布尔元类型"><a class="header" href="#字符布尔元类型">字符、布尔、元类型</a></h1>
<p>这三个类型所处的地位比较尴尬，你说它们重要吧，在需要的时候也是不可或缺，说它们不重要吧，确实出现的身影不是很多，而且这三个类型都有一个共同点：简单，因此我们统一放在一起讲。</p>
<h2 id="字符类型char"><a class="header" href="#字符类型char">字符类型(char)</a></h2>
<p>字符，对于没有其它编程经验的新手来说可能不太好理解(没有编程经验敢来学Rust的绝对是好汉)，如果用字母来表示就很好理解了。下文我们用<code>char</code>来指代字符。</p>
<p>下面的代码展示了几个颇具异域风情的字符：</p>
<pre><code>fn main() {
    let c = 'z';
    let z = 'ℤ';
    let g = '国';
    let heart_eyed_cat = '😻';
}
</code></pre>
<p>如果你从部分陈旧的语言来，可能会大喊一声：这XX叫字符？是的，在Rust语言中这些都是字符，Rust的字符不仅仅是<code>ASCII</code>，所有的<code>Unicode</code>值都可以作为Rust字符，包括中文/日文/韩文，emoji表情等等，都是合法的字符类型。Unicode 值的范围从 U+0000~U+D7FF 和 U+E000~U+10FFFF。不过“字符”并不是 Unicode 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p>
<p>由于Unicode都是4个字节编码，因此字符类型也是占用4个字节：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = '中';
    println!(&quot;字符'中'占用了{}字节的内存大小&quot;,std::mem::size_of_val(&amp;x));
}
</code></pre></pre>
<p>输出如下:</p>
<pre><code class="language-console">$ cargo run
   Compiling ...
    
字符'中'占用了4字节的内存大小
</code></pre>
<blockquote>
<p>注意，我们还没开始讲字符串，但是这里提前说一下，和一些语言不同，Rust的字符只能用<code>''</code>来表示,<code>&quot;&quot;</code>是留给字符串的</p>
</blockquote>
<h2 id="布尔bool"><a class="header" href="#布尔bool">布尔(bool)</a></h2>
<p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。布尔值占用内存的大小为 1 个字节。布尔类型使用 <code>bool</code> 指定。例如：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // 使用类型标注,显式指定f的类型

    if f {
        println!(&quot;这是段毫无意义的代码&quot;);
    }
}
</code></pre></pre>
<p>使用布尔类型的场景主要在于控制流，例如上述代码的中的<code>if</code>就是其中之一。</p>
<h2 id="元类型"><a class="header" href="#元类型">元类型</a></h2>
<p>元类型就是<code>()</code>，对，你没看错，就是<code>()</code>，唯一的值也是<code>()</code>，可能读者读到这里就不愿意了，你也太敷衍了吧，管这叫类型？</p>
<p>只能说，再不起眼的东西，都有其用途，在目前为止的学习过程中，大家已经看到过很多次<code>fn main()</code>函数的使用吧？那么这个函数返回什么呢？
没错就是这个元类型<code>()</code>，你不能说<code>main</code>函数无返回值，因为没有返回值的函数在Rust中是有单独的定义的：<code>发散函数</code>,顾名思义，无法收敛的函数.</p>
<p>例如常见的<code>println!()</code>的返回值也是<code>()</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句和表达式"><a class="header" href="#语句和表达式">语句和表达式</a></h1>
<p>Rust的函数体是由一系列语句组成，然后最后由一个表达式来返回值，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_with_extra(x: i32, y: i32) -&gt; i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
<span class="boring">}
</span></code></pre></pre>
<p>语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。</p>
<p>对于Rust语言而言，<strong>这种基于语句和表达式的方式是非常重要的，你需要能明确的区分这两个概念</strong>, 但是对于其它很多语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，表达式总要返回值。</p>
<p>在此之前，我们已经多次使用过语句和表达式, 先从语句讲起:</p>
<h2 id="语句"><a class="header" href="#语句">语句</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 8;
let b: Vec&lt;f64&gt; = Vec::new();
let (a, c) = (&quot;hi&quot;, false);
<span class="boring">}
</span></code></pre></pre>
<p>以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。</p>
<p>由于<code>let</code>是语句，因此不能将let语句赋值给其它值，如下形式是错误的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = (let a = 8);
<span class="boring">}
</span></code></pre></pre>
<p>错误如下: </p>
<pre><code class="language-console">error: expected expression, found statement (`let`) // 期望表达式，确发现`let`语句
 --&gt; src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement `let`是一条语句

error[E0658]: `let` expressions in this position are experimental // 下面的`let`用法目前是试验性的，在稳定版中尚不能使用
 --&gt; src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

</code></pre>
<p>以上的错误告诉我们<code>let</code>是语句，不是表达式，因此它不返回值，也就不能给其它变量赋值。但是该错误还透漏了一个重要的信息，<code>let</code>作为表达式已经是试验功能了，也许不久的将来，我们在<a href="basic/base-type/../../appendix/rust-dev.html"><code>stable rust</code></a>下可以这样使用。</p>
<h2 id="表达式"><a class="header" href="#表达式">表达式</a></h2>
<p>表达式会进行求值，然后返回一个值。例如<code>5 + 6</code>，在求值后，返回值<code>11</code>，因此它就是一条表达式。表达式可以成为语句的一部分，例如<code>let y= 6</code>中，<code>6</code>就是一个表达式，它在求值后返回一个值<code>6</code>(有些反直觉，但是确实是表达式)，调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式，无论简单还是复杂。例如：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>其中我们把一个语句块表达式的值赋给了y，语句块长这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 3;
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>该语句块是表达式的原因是：它的最后一行是表达式，返回了<code>x + 1</code>的值，注意<code>x + 1</code>不能以分号结尾，否则就会从表达式变成语句, <strong>表达式不能包含分号</strong>。这一点非常重要，一旦你在表达式后加上分号，它就会变成一条语句，再也不会返回一个值，请牢记！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>Rust的函数我们在之前已经见过不少，跟其他语言几乎没有什么区别。因此本章的学习之路将轻松和愉快，骚年们，请珍惜这种愉快，下一章你将体验到不一样的Rust。</p>
<p>在函数界，有一个函数只闻其名不闻其声，可以止小孩啼，在程序界只有<code>hello,world!</code>可以与之媲美，它就是<code>add</code>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(i: i32, j: i32) -&gt; i32 {
   i + j
 }
<span class="boring">}
</span></code></pre></pre>
<p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字<code>fn</code>,函数名<code>add()</code>,参数<code>i</code>和<code>j</code>，参数类型和返回值类型都是<code>i32</code>，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：</p>
<img alt="" src="basic/base-type//img/function-01.png" class="center"  />
<p>当你看懂了这张图，其实就等于差不多完成了函数章节的学习。但是这么短的章节显然对不起读者老爷们的厚爱，所以我们来展开下。</p>
<p>函数有以下需要注意的点：</p>
<ul>
<li>函数名和变量名使用<a href="basic/base-type/../../style-guide/naming.html">蛇形命名法(snake case)</a>，例如<code>fn add_two() -&gt; {}</code></li>
<li>函数的位置可以随便放，Rust不关心我们在哪里定义了函数，只要有定义即可</li>
<li>每个函数参数都需要标注类型</li>
</ul>
<h2 id="函数参数"><a class="header" href="#函数参数">函数参数</a></h2>
<p>Rust是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型，例如：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6.1);
}

fn another_function(x: i32, y: f32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p><code>another_function</code>函数有两个参数，其中<code>x</code>是<code>i32</code>类型，<code>y</code>是<code>f32</code>类型，然后在该函数内部，打印出这两个值。这里去掉<code>x</code>或者<code>y</code>的任何一个的类型，都会报错：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6.1);
}

fn another_function(x: i32, y) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>错误如下:</p>
<pre><code class="language-console">error: expected one of `:`, `@`, or `|`, found `)`
 --&gt; src/main.rs:5:30
  |
5 | fn another_function(x: i32, y) {
  |                              ^ expected one of `:`, `@`, or `|` // 期待以下符号之一 `:`, `@`, or `|` 
  |
  = note: anonymous parameters are removed in the 2018 edition (see RFC 1685) // 匿名参数在Rust 2018 edition中就已经移除
help: if this is a parameter name, give it a type // 如果y是一个参数名，请给予它一个类型
  |
5 | fn another_function(x: i32, y: TypeName) {
  |                             ~~~~~~~~~~~
help: if this is a type, explicitly ignore the parameter name // 如果y是一个类型，请使用_忽略参数名
  |
5 | fn another_function(x: i32, _: y) {
  |                             ~~~~
</code></pre>
<h2 id="函数返回"><a class="header" href="#函数返回">函数返回</a></h2>
<p>在上一章节语句和表达式中，我们提到在Rust中，函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。不像有些语言，会给返回值一个名称，在Rust中，只需要声明返回值的类型即可(在<code>-&gt;</code>之后，<code>{</code>之前})。</p>
<p>函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用<code>return</code>提前返回，下面的函数使用最后一条表达式来返回一个值：</p>
<pre><pre class="playground"><code class="language-rust">fn plus_five(x:i32) -&gt; i32 {
    x + 5
}

fn main() {
    let x = plus_five(5);

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p><code>x + 5</code>是一条表达式，求值后，返回一个值，因为它是函数的最后一行，因此该表达式的值也是函数的返回值。</p>
<p>再来看两个重点：</p>
<ol>
<li><code>let x = add_five(5)</code>，说明我们用一个函数的返回值来初始化<code>x</code>变量，因此侧面说明了在Rust中函数也是表达式， 这种写法等同于<code>let x = 5 + 5;</code></li>
<li><code>x + 5</code>没有分号，因为它是一条表达式，这个在上一节中我们也有详细介绍</li>
</ol>
<p>再来看一段代码，同时使用<code>return</code>和表达式作为返回值:</p>
<pre><pre class="playground"><code class="language-rust">fn plus_or_substract(x:i32) -&gt; i32 {
    if x &gt; 5 {
        return x - 5
    }

    x + 5
}

fn main() {
    let x = plus_or_substract(5);

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p><code>plus_or_substract</code>函数根据传入<code>x</code>的大小来决定是做加法还是减法，若<code>x &gt; 5</code>则通过<code>return</code>提前返回<code>x - 5</code>的值,否则返回<code>x + 5</code>的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权和借用"><a class="header" href="#所有权和借用">所有权和借用</a></h1>
<p>Rust之所以能成为万众瞩目的语言，就是因为其内存安全性。在以往，内存安全几乎都是通过GC的方式实现，但是GC会引来性能、内存占用以及Stop the world等问题，在高性能场景和系统编程上是不可忍受的，因此Rust采用了与中不同的方式：<strong>所有权系统</strong>。</p>
<p>理解所有权和借用，对于Rust学习是至关重要的，因此我们把本章提到了非常靠前的位置。</p>
<p>从现在开始，鉴于大家已经掌握了非常基本的语法，有些时候，在示例代码中，将省略<code>fn main{}</code>的模版代码，你只要将相应的示例放在<code>fn main{}</code>中，即可运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权"><a class="header" href="#所有权">所有权</a></h1>
<p>所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：</p>
<ul>
<li><strong>垃圾回收机制(GC)</strong>，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go</li>
<li><strong>手动管理内存的分配和释放</strong>, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++</li>
<li><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查</li>
</ul>
<p>其中Rust选择了第三种，最妙的是，这种只发生在编译器，因此对于程序运行期，不会有任何性能上的损失。</p>
<p>因为所有权是一个新概念，因此读者需要花费一些时间来掌握它，一旦掌握，海阔天空任你跃，在本章，我们将通过<code>字符串</code>来引导讲解所有权的相关知识。</p>
<h2 id="一段不安全的代码"><a class="header" href="#一段不安全的代码">一段不安全的代码</a></h2>
<p>先来看看C语言的一段糟糕代码：</p>
<pre><code class="language-c">int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = &quot;xyz&quot;;   // 变量c的作用域开始
    return &amp;a;
}                   // 变量a和c的作用域结束
</code></pre>
<p>这段代码虽然可以编译通过，但是其实非常糟糕，变量<code>a</code>和<code>c</code>都是局部变量，函数结束后将局部变量<code>a</code>的地址返回，但局部变量<code>a</code>存在栈中，在离开作用域后，局部变量所申请的栈上内存都会被系统回收，从而造成了<code>悬空指针(Dangling Pointer)</code>的问题。这是一个非常典型的内存安全问题。很多编程语言都存在类似这样的内存安全问题。再来看变量<code>c</code>，<code>c</code>的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，我们可能不再想使用这个字符串，但<code>xyz</code>只有当整个程序结束后系统才能回收这片内存，这点让程序员是不是也很无奈？</p>
<p>所以内存安全问题，一直都是程序员非常头疼的问题，好在在Rust中，这些问题即将成为历史，那Rust如何做到这一点呢？</p>
<p>在正式进入主题前，先来一个预热知识。</p>
<h2 id="栈stack与堆heap"><a class="header" href="#栈stack与堆heap">栈（Stack）与堆（Heap）</a></h2>
<p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要经常考虑到栈与堆。 不过对于Rust这样的系统编程语言，值是位于栈上还是堆上非常重要,因为这会影响程序的行为和性能。</p>
<p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间，关于它们的详细解释和实现方式，请参见<a href="https://codes.rs/data-structures/heap.html">Rust代码鉴赏</a>一书.</p>
<h4 id="栈"><a class="header" href="#栈">栈</a></h4>
<p>栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>进栈</strong>，移出数据则叫做 <strong>出栈</strong>。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定的大小的内存空间，如果数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h4 id="堆"><a class="header" href="#堆">堆</a></h4>
<p>与栈不同，对于大小位置或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，你需要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>。这个过程称作 <strong>在堆上分配内存</strong>，有时简称为 “分配”（allocating）。 接着，该指针会被推入<code>栈</code>中，因为指针的大小时已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>因此堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后它找到一个够大的空桌子(堆上分配的内存空间)并领你们过去。如果有人来迟了，他们也可以通过桌号(栈上的指针)来找到你们坐在哪。</p>
<h4 id="性能区别"><a class="header" href="#性能区别">性能区别</a></h4>
<p>入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间：新数据的位置放入栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。得益于CPU高速缓存，现代处理器访问内存的次数越少则越快。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜,在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。但是如果在桌子A点菜完，再去一个比较远的桌子B点菜，就会比较慢。</p>
<p>出于同样原因，处理器在处理栈上数据的时候比处理堆上的数据更加高效，同时，在堆上分配大量的空间也可能消耗时间。</p>
<h4 id="所有权与堆栈"><a class="header" href="#所有权与堆栈">所有权与堆栈</a></h4>
<p>当你的代码调用一个函数时，传递给函数的参数(包括可能指向堆上数据的指针和函数的局部变量)依次被压入栈中, 当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏:这些数据将永远无法被回收。这就是Rust所有权系统为我们提供的强大保障。 </p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是在Rust中，明白堆栈的原理，对于我们理解所有权的工作原理会有帮助.</p>
<h2 id="所有权原则"><a class="header" href="#所有权原则">所有权原则</a></h2>
<p>理解了堆栈，接下来看一下<em>关于所有权的规则</em>，首先请谨记以下规则：</p>
<blockquote>
<ol>
<li>Rust中每一个值都<code>有且只有</code>一个所有者(变量)</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃</li>
</ol>
</blockquote>
<h4 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h4>
<p>作用域是一个变量在程序中有效的范围, 假如有这样一个变量：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;
<span class="boring">}
</span></code></pre></pre>
<p>变量<code>s</code>绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。<code>s</code>变量从声明的点开始直到当前作用域的结束都是有效的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s 在这里无效, 它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s 不再有效
<span class="boring">}
</span></code></pre></pre>
<p>简而言之，<code>s</code>从创建伊始就开始有效，然后有效期持续到它离开作用域为止，可以看出，就作用域这个概念，Rust语言跟其他编程语言没有区别。</p>
<h4 id="简单介绍string类型"><a class="header" href="#简单介绍string类型">简单介绍String类型</a></h4>
<p>之前提到过，本章会用String作为例子，因此这里会进行一下简单的介绍，具体的String学习请参见<a href="basic/ownership/../string.html">String类型</a>。</p>
<p>我们已经见过字符串字面值<code>let s =&quot;hello&quot;</code>，即被硬编码进程序里的字符串值。字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：</p>
<ul>
<li>字符串字面值是不可变的,因为被硬编码到程序代码中</li>
<li>并非所有字符串的值都能在编写代码时就知道</li>
</ul>
<p>例如，要是想获取用户输入并存储该怎么办呢？这种情况，字符串字面值就完全无用武之地，为此，Rust 有第二个字符串类型，String。这个类型被分配到堆上，所以能够存储在编译时未知大小的文本，可以使用下面的方法基于字符串字面量来创建<code>String</code>类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>::</code>是一种调用操作符，这里表示调用<code>String</code>中的<code>from</code>方法，因为String存储在堆上，你也可以修改它：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值

println!(&quot;{}&quot;, s); // 将打印 `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>那么问题来了，为啥<code>String</code>可变，而字符串字面值却不可以？</p>
<h2 id="内存与分配"><a class="header" href="#内存与分配">内存与分配</a></h2>
<p>就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的：</p>
<ul>
<li>首先向操作系统请求内存来存放<code>String</code>对象</li>
<li>在使用完成后，将内存释放，归还给操作系统</li>
</ul>
<p>其中第一个由<code>String::from</code>完成，它创建了一个全新的String.</p>
<p>重点来了，到了第二部分，就是百家齐放的环节，在有<strong>垃圾回收GC</strong>的语言中，GC来负责标记并清除这些不再使用的内存对象，这些都是自动完成，无需开发者关心，非常简单好用；在无GC的语言，是开发者手动去释放这些内存对象，就像创建对象一样，需要通过编写代码来完成，因为未能正确释放对象造成的经济简直不可估量.</p>
<p>对于Rust而言，安全和性能是写到骨子里的核心特性，使用GC牺牲了性能，使用手动管理内存牺牲了安全，那该怎么办？为此，Rust的开发者想出了一个无比惊艳的办法：变量在离开作用域后，就自动释放其占用的内存:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效，内存被释放
<span class="boring">}
</span></code></pre></pre>
<p>与其它系统编程语言的<code>free</code>函数相同，Rust也提供了一个释放内存的函数:<code>drop</code>，但是不同的是，其它语言要手动调用<code>free</code>来释放每一个变量占用的内存，而Rust则在变量离开作用域时，自动调用<code>drop</code>函数: 上面代码中，Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。</p>
<blockquote>
<p>其实，在 C++ 中，也有这种概念: <em>Resource Acquisition Is Initialization (RAII)</em>。如果你使用过 RAII 模式的话应该对 Rust 的 <code>drop</code> 函数并不陌生</p>
</blockquote>
<p>这个模式对编写 Rust 代码的方式有着深远的影响，不过上面的例子还是太简单，来看看其它场景。</p>
<h2 id="变量绑定背后的数据交互"><a class="header" href="#变量绑定背后的数据交互">变量绑定背后的数据交互</a></h2>
<h4 id="转移所有权"><a class="header" href="#转移所有权">转移所有权</a></h4>
<p>先来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p>代码背后的逻辑很简单:“将 5 绑定到变量x；接着拷贝x的值赋给y”,最终<code>x</code>和<code>y</code>都等于<code>5</code>,因为整数是由固定大小的简单值，因此这两个值都被存在栈中，完全无需在堆上分配内存。</p>
<p>可能有同学会有疑问：这种拷贝不消耗性能吗？实际上，这种栈上数据的拷贝非常非常快，而且数据本身也足够简单，只要复制一个整数大小的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。实际上，上一章我们讲到的Rust基本类型都是通过自动拷贝的方式来赋值的，就像上面代码一样。</p>
<p>然后再来看一段代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>此时，可能某个大聪明(善意昵称)已经想到了：嗯，把s1的内容拷贝一份赋值给s2，实际上，并不是这样。之前也提到了，对于基本类型(存储在栈上)，Rust会自动拷贝，但是<code>String</code>不是基本类型，而是存储在堆上的，因此并不能自动拷贝。</p>
<p>实际上，<code>String</code>类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有Go语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小, 详情见<a href="basic/ownership/../string.html#String%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90">字符串</a>一节.</p>
<p>总之<code>String</code>类型指向了一个堆上的空间，这里存储着它的真实数据，这里对上面代码中的<code>let s2 = s1</code>分成两种情况讨论：</p>
<ol>
<li>
<p>拷贝所有数据
如果该语句是拷贝所有数据(深拷贝)，那么无论是<code>String</code>本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p>
</li>
<li>
<p>只拷贝<code>String</code>本身
这样的拷贝非常快，因为在64位机器上就拷贝了<code>8字节的指针</code>、<code>8字节的长度</code>、<code>8字节的容量</code>，总计24字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是，一个值只允许有一个所有者，而现在这个值(堆上的真实字符串数据)有了两个所有者：<code>s1</code>和<code>s2</code>。</p>
</li>
</ol>
<p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p>
<p>之前我们提到过当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过由于两个<code>String</code>指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>因此，Rust这样解决问题：<strong>当<code>s1</code>赋予<code>s2</code>后，Rust认为<code>s1</code>不再有效，因此也无需在<code>s1</code>离开作用域后<code>drop</code>任何东西，这就是把所有权从<code>s1</code>转移给了<code>s2</code></strong>.</p>
<p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre></pre>
<p>因为Rust禁止你使用无效的引用，你会看到以下的错误</p>
<pre><code class="language-console">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>现在再回头看看之前的规则，相信你已经有了更深刻的理解：</p>
<blockquote>
<ol>
<li>Rust中每一个值都<code>有且只有</code>一个所有者(变量)</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃</li>
</ol>
</blockquote>
<p>如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量<code>s1</code>无效了，因此这个操作被称为 移动（move），而不是浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中。那么具体发生了什么，用一张图简单说明：</p>
<img alt="s1 moved to s2" src="basic/ownership//img/ownership01.svg" class="center" style="width: 50%;" />
<p>这样就解决了我们的问题，s1不再指向任何数据，只有s2是有效的，当<code>s2</code>离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么Rust称呼<code>let a = b</code>这种为<strong>变量绑定</strong>了吧？</p>
<h4 id="克隆深拷贝"><a class="header" href="#克隆深拷贝">克隆(深拷贝)</a></h4>
<p>首先，<strong>Rust 永远也不会自动创建数据的 “深拷贝”</strong>。因此，任何<strong>自动</strong>的复制可以被认为对运行时性能影响较小。</p>
<p>如果我们<strong>确实</strong>需要深度复制<code>String</code>中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做<code>clone</code>的方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>这段代码能够正常运行，因此说明s2确实完整的复制了s1的数据。</p>
<p>如果代码性能无关紧要，例如初始化程序时，或者在某段时间只会执行一次时，你可以使用<code>clone</code>来简化编程。但是对于执行较为频繁的代码，使用<code>clone</code>会极大的降低程序性能，需要小心使用！</p>
<h4 id="拷贝浅拷贝"><a class="header" href="#拷贝浅拷贝">拷贝(浅拷贝)</a></h4>
<p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p>
<p>再回到之前看过的例子:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过依然实现了类似深拷贝的效果 - 没有报所有权的错误。</p>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 <code>Copy</code>的特征，可以用在类似整型这样的存储在栈上的类型上。如果一个类型拥有 <code>Copy</code>特征，一个旧的变量在将其赋值给其他变量后仍然可用。</p>
<p>那么什么类型是 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则:<strong>任何基本类型的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的</strong>。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<h2 id="函数传值与返回"><a class="header" href="#函数传值与返回">函数传值与返回</a></h2>
<p>将值传递给函数，一样会发生<code>移动</code>或者<code>复制</code>，就跟<code>let</code>语句一样，下面的代码展示了所有权、作用域的规则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!(&quot;{}&quot;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!(&quot;{}&quot;, some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre></pre>
<p>你可以尝试在<code>takes_ownership</code>之后，再使用<code>s</code>，看看如何报错？例如添加一行<code>println!(&quot;在move进函数后继续使用s: {}&quot;,s);</code>。</p>
<p>同样的，函数返回值也有所有权，例如:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></pre>
<p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦，你总要把一个值传来传去去使用它，传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust提供了新功能解决这个问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用与借用"><a class="header" href="#引用与借用">引用与借用</a></h1>
<p>上节中提到，如果仅仅是所有权转移，会让程序变得复杂，那能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是有的。</p>
<p>Rust通过<code>借用(Borrowing)</code>这个概念来达成上述的目的: <strong>获取变量的引用，称之为借用(borrowing)</strong>。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主.</p>
<h3 id="引用与解引用"><a class="header" href="#引用与解引用">引用与解引用</a></h3>
<p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个<code>i32</code>值的引用<code>y</code>，然后使用解引用运算符来解出<code>y</code>所使用的值:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code>是 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来解出引用所指向的值（也就是 <strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p>
<p>相反如果尝试编写 <code>assert_eq!(5, y);</code>，则会得到如下编译错误：</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}` // 无法比较整数类型和引用类型
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>不允许比较整数与引用，因为它们是不同的类型。必须使用解引用运算符解出引用所指向的值。</p>
<h3 id="不可变引用"><a class="header" href="#不可变引用">不可变引用</a></h3>
<p>下面的代码，我们用s1的引用作为参数传递给<code>calculate_length</code>函数，而不是把s1的所有权转移给该函数：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>能注意到两点：</p>
<ol>
<li>无需再通过函数参数来传入所有权，通过函数返回来传出所有权，代码更加简洁</li>
<li><code>calculate_length</code>的参数<code>s</code>类型从<code>String</code>变为<code>&amp;String</code></li>
</ol>
<p>这里，<code>&amp;</code>符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：
<img alt="&String s pointing at String s1" src="basic/ownership//img/borrowing-01.svg" class="center" />
<span class="caption">图：<code>&amp;String s</code> 指向 <code>String s1</code>的示意图</span></p>
<p><code>&amp;s1</code>语法，让我们创建一个<strong>指向s1的引用</strong>，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</p>
<p>同理，函数<code>calculate_length</code>使用<code>&amp;</code>来表明参数<code>s</code>的类型是一个引用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
<span class="boring">}
</span></code></pre></pre>
<p>人总是贪心的，可以摸女孩手了，就想着摸摸胳膊(读者中的老司机表示，这个流程完全不对)，因此光借用已经满足不了我们了，如果尝试修改借用的变量呢？</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>很不幸，胳膊你没摸到, 哦口误，你修改错了：</p>
<pre><code class="language-console">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
                           ------- 帮助：考虑将该参数类型修改为可变的引用: `&amp;mut String`
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
                     `some_string`是一个`&amp;`类型的引用，因此它指向的数据无法进行修改
</code></pre>
<p>正如变量默认不可变一样，引用指向的值默认也是不可变的，没事，来一起看看如果解决这个问题。</p>
<h3 id="可变引用"><a class="header" href="#可变引用">可变引用</a></h3>
<p>只需要一个小调整，既可以修复上面代码的错误：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>首先，声明<code>s</code>是可变类型，其次创建一个可变的引用<code>&amp;mut s</code>和接受可变引用的函数<code>some_string: &amp;mut String</code>。</p>
<h5 id="可变引用同时只能存在一个"><a class="header" href="#可变引用同时只能存在一个">可变引用同时只能存在一个</a></h5>
<p>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制：同一作用域，特定数据只能由一个可变引用:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre></pre>
<p>以上代码会报错：</p>
<pre><code class="language-console">error[E0499]: cannot borrow `s` as mutable more than once at a time 同一时间无法对`s`进行两次可变借用
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here 首个可变引用在这里借用
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here 第二个可变引用在这里借用
6 |     
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here 第一个借用在这里使用
</code></pre>
<p>这段代码出错的原因在于，第一个可变借用<code>r1</code>必须要持续到最后一次使用的位置<code>println!</code>，在<code>r1</code>创建和最后一次使用之间，我们又尝试创建第二个引用<code>r2</code>。
对于新手来说，这个特性绝对是一大拦路虎，也是新人们谈之色变的编译器<code>borrow checker</code>特性之一，不过各行各业都一样，限制往往是出于安全的考虑，Rust也一样。</p>
<p>这种限制的好处就是使Rust在编译期就避免数据竞争，数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p>
<p>很多时候，大括号可以帮我们解决一些问题，通过手动限制变量的作用域：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<h5 id="可变引用与不可变引用不能同时存在"><a class="header" href="#可变引用与不可变引用不能同时存在">可变引用与不可变引用不能同时存在</a></h5>
<p>下面的代码会导致一个错误：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // 没问题
let r2 = &amp;s; // 没问题
let r3 = &amp;mut s; // 大问题

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre></pre>
<p>错误如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable 无法借用可变`s`因为它已经被借用了不可变
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // 没问题
  |              -- immutable borrow occurs here 不可变借用发生在这里
5 |     let r2 = &amp;s; // 没问题
6 |     let r3 = &amp;mut s; // 大问题
  |              ^^^^^^ mutable borrow occurs here 可变借用发生在这里
7 |     
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here 不可变借用在这里使用
<span class="boring">}
</span></code></pre></pre>
<p>其实这个也很好理解，借用了不可变的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，然后导致别人的数据被污染。</p>
<blockquote>
<p>注意，引用的作用域从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号<code>}</code></p>
</blockquote>
<p>Rust的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; 
    let r2 = &amp;s; 
    println!(&quot;{} and {}&quot;, r1, r2);
    // 新编译器中，r1,r2作用域在这里结束

    let r3 = &amp;mut s; 
    println!(&quot;{}&quot;, r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
  // 新编译器中，r3作用域在这里结束
</code></pre></pre>
<p>在老的编译器中（Rust 1.31前），将会报错，因为<code>r1</code>和<code>r2</code>的作用域在花括号<code>}</code>处结束，那么<code>r3</code>的借用就会触发<strong>无法同时借用可变和不可变</strong>的规则。</p>
<p>但是在新的编译器中，该代码将顺利通过，因为<strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>,因此<code>r1</code>借用和<code>r2</code>借用在<code>println!</code>后，就结束了，此时<code>r3</code>可以顺利借用到可变引用。</p>
<p>对于这种编译器优化行为，Rust专门起了一个名字 - Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(<code>}</code>)结束前就不再被使用的代码位置。</p>
<p>虽然这种借用错误有的时候会让我们很郁闷，但是你只要想想这是Rust提前帮你发现了潜在的bug，其实就开心了，虽然减慢了开发速度，但是从长期来看，大幅减少了后续开发和运维成本.</p>
<h3 id="悬垂引用dangling-references"><a class="header" href="#悬垂引用dangling-references">悬垂引用（Dangling References）</a></h3>
<p>所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>让我们尝试创建一个悬垂引用，Rust 会通过一个编译时错误来避免：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>这里是错误：</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

</code></pre>
<p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。<a href="basic/ownership/../../advance/lifetime.html">该章</a>会详细介绍生命周期。不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息：</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value for it to be borrowed from.
该函数返回了一个借用的值，但是已经找不到它所借用值的来源
</code></pre>
<p>让我们仔细看看我们的 <code>dangle</code> 代码的每一步到底发生了什么：</p>
<pre><code class="language-rust ignore does_not_compile">fn dangle() -&gt; &amp;String { // dangle 返回一个字符串的引用

    let s = String::from(&quot;hello&quot;); // s 是一个新字符串

    &amp;s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险！
</code></pre>
<p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！Rust 不会允许我们这么做。</p>
<p>这里的解决方法是直接返回 <code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<p>这样就没有任何错误了。所有权被移动出去，所以没有值被释放。</p>
<h2 id="借用规则总结"><a class="header" href="#借用规则总结">借用规则总结</a></h2>
<p>总的来说，借用规则如下：</p>
<ul>
<li>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</li>
<li>引用必须总是有效的</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h1>
<p>行百里者半50，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。</p>
<p>本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而来，最典型的就是结构体<code>struct</code>和枚举<code>enum</code>。例如一个2D的点<code>point(x,y)</code>似乎从两个数值类型组合而来。我们不想单独去维护这两个数值，而是希望把它们看作一个整体去认识和处理。</p>
<p>来看一段代码，它使用我们之前学过的内容来构建文件操作：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused_variables)]
 
 type File = String;
 
 fn open(f: &amp;mut File) -&gt; bool {
     true
 }
 fn close(f: &amp;mut File) -&gt; bool {
     true
 }
 
 #[allow(dead_code)]
 fn read(f: &amp;mut File, save_to: &amp;mut Vec&lt;u8&gt;) -&gt; ! {
     unimplemented!()
 }
 
 fn main() {
     let mut f1 = File::from(&quot;f1.txt&quot;);
     open(&amp;mut f1);
     //read(&amp;mut f1, &amp;mut vec![]);
     close(&amp;mut f1);
 }
</code></pre></pre>
<p>目前阶段非常类似原型设计：提供api接口，但是不去实现它们。因此在这个阶段我们需要排除一些编译器噪音，引入了<code>#![allow(unused_variables)]</code>属性标记，该标记会告诉编译器无视未使用的变量，不要抛出<code>warning</code>警告,具体的常见编译器属性你可以在这里查阅：<a href="basic/compound-type/../../compiler/attributes.html">编译器属性标记</a>.</p>
<p><code>read</code>函数也非常有趣，它返回一个<code>!</code>，这个表明该函数是一个发散函数，不会返回任何值，包括<code>()</code>，<code>unimplemented!()</code>告诉编译器该函数尚未实现，其实主要帮助我们快速完成主要代码，回头可以通过搜索这些标记来完成次要代码，类似的还有<code>todo!()</code>.当代码执行到这种语句使，编译器会直接报错，你可以反注释<code>read(&amp;mut f1, &amp;mut vec![]);</code>这行，然后再尝试运行程序。</p>
<p>同时，从代码设计角度来看，关于文件操作的类型和函数散落的到处都是，特别是当文件属性和相关的操作多了后，更是难以管理，而且<code>open(&amp;mut f1)</code>也远没有<code>f1.open()</code>好，因此这就是基本类型的局限性：<strong>无法从更高的抽象层次去简化代码</strong>。</p>
<p>接下来，我们将引入结构体这个高级数据结构，来看看怎么样更好的解决这类问题，开始之前，先来看看何为<code>元组</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串与切片"><a class="header" href="#字符串与切片">字符串与切片</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组也是复合类型的一种，因此它是由多种类型组合到一起形成的。元组的长度是固定的，且在声明后，无法进行伸缩。</p>
<p>通过以下语法可以创建一个元组：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>变量<code>tup</code>被绑定了一个元组值<code>(500, 6.4, 1)</code>，该元组的类型是<code>(i32, f64, u8)</code>，看到没？元组是用括号将多个类型组合到一起，简单吧？</p>
<p>从元组中获取值有两种方式：</p>
<h3 id="用模式匹配解构元组"><a class="header" href="#用模式匹配解构元组">用模式匹配解构元组</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>上述代码首先创建一个元组，然后将其绑定到<code>tup</code>上，接着使用<code>let (x, y, z) = tup;</code>来完成一次模式匹配，因为元组是(n1,n2,n3)形式的，因此我们用一模一样的<code>(x,y,z)</code>形式来进行匹配，然后把元组中对应的值绑定到变量<code>x</code>，<code>y</code>，<code>z</code>上，这就是解构：用同样的形式把一个复杂对象中子值匹配出来。</p>
<h3 id="用来访问元组"><a class="header" href="#用来访问元组">用<code>.</code>来访问元组</a></h3>
<p>模式匹配可以让我们一次性把元组全部获取出来，如果想要访问某个元素，那模式匹配就略显繁琐，对此，Rust提供了<code>.</code>的访问方式：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>和其它语言的数组、字符串一样，元组的索引从0开始。</p>
<h3 id="元组的使用示例"><a class="header" href="#元组的使用示例">元组的使用示例</a></h3>
<p>元组在函数返回值场景很常用，例如下面的代码，可以使用元组返回多个值:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
</code></pre></pre>
<p><code>calculate_length</code>函数接收<code>s1</code>字符串的所有权，然后计算字符串的长度，接着把字符串所有权和字符串长度返回给<code>s2</code>和<code>len</code>变量。</p>
<p>对于其他语言，元组可以用来声明一个3D点，例如<code>Point(10,20,30)</code>，虽然使用Rust元组也可以做到：<code>(10,20,30)</code>，但是这样写有个非常重大的缺陷：
不具备任何清晰的含义，在下一章节中，会提到一种<code>元组结构体</code>，可以解决这个问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>在上一节，我们提到需要一个更高级的数据结构来帮助我们更好的抽象问题，而结构体<code>strct</code>恰恰就是这样的复合数据结构，它是由其它数据类型组合而来, 其它语言也有类似的数据结构，不过可能有不同的名称，例如<code>object</code>、<code>record</code>等。</p>
<p>结构体跟之前讲过的<a href="basic/compound-type/../base-type/tuple.html">元组</a>有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它们。</p>
<h2 id="结构体语法"><a class="header" href="#结构体语法">结构体语法</a></h2>
<p>天下无敌的剑士往往也因为他有一炳无双之剑，既然结构体这么强大，那么我们就需要给它配套一套强大的语法，让用户能更好的驾驭。</p>
<h4 id="定义结构体"><a class="header" href="#定义结构体">定义结构体</a></h4>
<p>定义结构体有几部分组成：</p>
<ul>
<li>通过关键字<code>struct</code>定义</li>
<li>一个清晰明确的结构体<code>名称</code></li>
<li>数个具名的结构体<code>字段</code></li>
</ul>
<p>例如以下结构体定义了某网站的用户：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>该结构体名称是<code>User</code>，拥有4个具名的字段，且每个字段都有对应的类型声明，例如<code>username</code>代表了用户名，是一个可变的<code>String</code>类型。</p>
<h4 id="创建结构体实例"><a class="header" href="#创建结构体实例">创建结构体实例</a></h4>
<p>为了使用上述结构体，我们需要创建<code>User</code>结构体的<code>实例</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
};
<span class="boring">}
</span></code></pre></pre>
<p>有几点值得注意:</p>
<ol>
<li>初始化实例时，需要为每个字段都进行初始化</li>
<li>初始化时的字段顺序无需按照定义的顺序来</li>
</ol>
<h4 id="访问结构体字段"><a class="header" href="#访问结构体字段">访问结构体字段</a></h4>
<p>通过<code>.</code>操作符即可访问结构体实例内部的字段值，并且也可以修改它们：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是，必须要将整个结构体都声明为可变的，才能修改它，Rust不允许单独将某个字段标记为可变: <code>let mut user1 = User {...}</code>.</p>
<h4 id="简化结构体创建"><a class="header" href="#简化结构体创建">简化结构体创建</a></h4>
<p>先看以下这个函数:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它接收两个字符串参数：<code>email</code>和<code>username</code>，然后使用它们来创建一个<code>User</code>结构体，并且返回。可以注意到这两行：<code>email: email</code>和<code>username: username</code>，非常的扎眼，因为实在太啰嗦了，如果你从typscript过来，肯定会鄙视Rust一番，不过好在，它也不是无可救药:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟<code>typescript</code>中一模一样.</p>
<h4 id="结构体更新语法"><a class="header" href="#结构体更新语法">结构体更新语法</a></h4>
<p>在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的<code>user1</code>实例来构建<code>user2</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}
</span></code></pre></pre>
<p>老话重提，如果你从typescript过来，肯定觉得啰嗦爆了，手动把user1的三个字段逐个赋值给user2，好在Rust为我们提供了<code>结构体更新语法</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>user2</code>仅仅在<code>email</code>上与<code>user1</code>不同，因此我们只需要对<code>email</code>进行赋值，剩下的通过结构体更新语法<code>..user1</code>即可完成。</p>
<p><code>..</code>语法说明我们没有显示声明的字段全部从<code>user1</code>中自动获取。需要注意的是<code>..user1</code>必须在结构体的尾部使用。</p>
<blockquote>
<p>结构体更新语法跟赋值语句<code>=</code>非常相像，因此在上面代码中，<code>user1</code>的部分字段所有权被转移到<code>user2</code>中：<code>username</code>字段发生了所有权转移,作为结果，<code>user1</code>无法再被使用。</p>
<p>聪明的读者肯定要发问了：明明有三个字段进行了自动赋值，为何只有<code>username</code>发生了所有权转移？</p>
<p>仔细回想一下<a href="basic/compound-type/../ownership/ownership.html">所有权</a>那一节的内容，我们提到了Copy特征：实现了Copy特征的类型无需所有权转移，可以直接在赋值时进行
数据拷贝，其中<code>bool</code>和<code>u64</code>类型就实现了<code>Copy</code>特征，因此<code>active</code>和<code>sign_in_count</code>字段在赋值给user2时，仅仅发生了拷贝，而不是所有权转移.</p>
<p>值的注意的是：<code>username</code>所有权被转移给了<code>user2</code>,导致了<code>user1</code>无法再被使用，但是并不代表<code>user1</code>内部的字段不能被急需使用，例如:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };

    println!(&quot;{}&quot;, user1.active);

    // 下面这行会报错
    //println!(&quot;{}&quot;, user1);
<span class="boring">}
</span></code></pre></pre>
<h2 id="结构体的内存排列"><a class="header" href="#结构体的内存排列">结构体的内存排列</a></h2>
<p>先看以下代码：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
 struct File {
   name: String,
   data: Vec&lt;u8&gt;,
 }
 
 fn main() {
   let f1 = File {
     name: String::from(&quot;f1.txt&quot;),
     data: Vec::new(),
   };
 
   let f1_name = &amp;f1.name;
   let f1_length = &amp;f1.data.len();
 
   println!(&quot;{:?}&quot;, f1);
   println!(&quot;{} is {} bytes long&quot;, f1_name, f1_length);
 }
</code></pre></pre>
<p>上面定义的<code>File</code>结构体在内存中的排列如下图所示：
<img alt="" src="basic/compound-type//img/struct-01.png" class="center"  /></p>
<p>从图中可以清晰的看出<code>File</code>结构体两个字段<code>name</code>和<code>data</code>分别拥有底层两个<code>[u8]</code>数组的所有权(<code>String</code>类型的底层也是<code>[u8]</code>数组)，通过<code>ptr</code>指针指向底层数组的内存地址,这里你可以把<code>ptr</code>指针理解为Rust中的引用类型。</p>
<p>该图片也侧面印证了：把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段.</p>
<h2 id="元组结构体tuple-struct"><a class="header" href="#元组结构体tuple-struct">元组结构体(Tuple Struct)</a></h2>
<p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的<code>Point</code>元组结构体，众所周知3D点是<code>(x,y,x)</code>形式的坐标点，因此我们无需再为内部的字段逐一命名为：<code>x</code>,<code>y</code>,<code>z</code>。</p>
<h2 id="元结构体unit-like-struct"><a class="header" href="#元结构体unit-like-struct">元结构体(Unit-like Struct)</a></h2>
<p>还记得之前讲过的基本没啥用的<a href="basic/compound-type/../base-type/char-bool.html#%E5%85%83%E7%B1%BB%E5%9E%8B">元类型</a>吧? 元结构体就跟它很像，没有任何字段和属性，但是好在，它还挺有用。</p>
<p>如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用<code>元结构体</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AlwaysEqual;

let subject = AlwaysEqual;

// 我们不关心为AlwaysEqual的字段数据，只关心它的行为，因此将它声明为元结构体，然后再为它实现某个特征
impl AlwaysEqual for SomeTrait {
    
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="结构体数据的所有权"><a class="header" href="#结构体数据的所有权">结构体数据的所有权</a></h2>
<p>在之前的<code>User</code> 结构体的定义中，我们使用了自身拥有所有权的 <code>String</code> 类型而不是基于引用的<code>&amp;str</code> 字符串切片类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据。</p>
<p>你也可以让<code>User</code>结构体从其它对象借用数据，不过这么做，就需要引入<strong>生命周期</strong>这个新概念(也是一个复杂的概念),简而言之，生命周期能确保结构体的作用范围要比它所借用的数据的作用范围要大。</p>
<p>总之，如果你想在结构体中使用一个引用，就必须加上生命周期，否则就会报错：</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p>编译器会抱怨它需要生命周期标识符：</p>
<pre><code class="language-console">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter // 需要一个生命周期
  |
help: consider introducing a named lifetime parameter // 考虑像下面的代码这样引入一个生命周期
  |
1 ~ struct User&lt;'a&gt; {
2 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     username: &amp;str,
3 ~     email: &amp;'a str,
  |
</code></pre>
<p>未来在<a href="basic/compound-type/../../advance/lifetime.html">生命周期</a>中会讲到如何修复这个问题以便在结构体中存储引用，不过在那之前，我们会避免在结构体中使用引用类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>枚举(enum或enumeration)允许你通过列举可能的成员来定义一个**<code>枚举类型</code>**,例如扑克牌花色：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果在此之前你没有在其它语言中使用过枚举，那么可能需要花费一些时间来理解这些概念，一旦上手，就会发现枚举的强大，甚至对它爱不释手，枚举虽好，可不要滥用哦。</p>
<p>再回到之前创建的<code>PokerSuit</code>，扑克总共有四种花色，而这里我们枚举出所有的可能值，这也正是<code>枚举</code>名称的由来。</p>
<p>任何一张扑克，它的花色肯定会落在四种花色中，而且也只会落在其中一个花色上，这种特性非常适合枚举的使用，因为**<code>枚举值</code>**只可能是其中一个成员。抽象来看，四种花色尽管是不同的花色，但是它们都是扑克花色这个概念，因此当某个函数处理扑克花色时，可以把它们当作相同的类型进行传参。</p>
<p>细心的读者应该注意到，我们对之前的<code>枚举类型</code>和<code>枚举值</code>进行了重点标注，这是因为对于新人来说容易混淆相应的概念，总而言之：
<strong>枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实现。</strong></p>
<h2 id="枚举值"><a class="header" href="#枚举值">枚举值</a></h2>
<p>现在来创建<code>PokerSuit</code>枚举类型的两个成员实例:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
<span class="boring">}
</span></code></pre></pre>
<p>我们通过<code>::</code>操作符来访问<code>PokerSuit</code>下的具体成员，从代码可以清晰看出，<code>heart</code>和<code>diamond</code>都是<code>PkerSuit</code>枚举类型的，接着可以定义一个函数来使用它们：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let heart = PokerSuit::Hearts;
    let diamond = PokerSuit::Diamonds;

    print_suit(heart);
    print_suit(diamond);
}

fn print_suit(card: PokerSuit) {
    println!(&quot;{:?}&quot;,card);
}
</code></pre></pre>
<p><code>print_suit</code>函数的参数类型是<code>PokerSuit</code>，因此我们可以把<code>heart</code>和<code>diamond</code>传给它，虽然<code>heart</code>是基于<code>PokerSuit</code>下的<code>Hearts</code>成员实例化的，但是它是货真价实的<code>PokerSuit</code>枚举类型。</p>
<p>接下来，我们想给扑克牌变得更加实用，那么需要给每张牌赋予一个值：<code>A</code>(1)-<code>K</code>(13)，这样再加上花色，就是一张真实的扑克牌了，例如红心A。</p>
<p>目前来说，枚举值还不能带有值，因此先用结构体来实现：</p>
<pre><pre class="playground"><code class="language-rust">enum PokerSuit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}

struct PokerCard {
    suit: PokerSuit,
    value: u8
}

fn main() {
   let c1 = PokerCard {
       suit: PokerSuit::Clubs,
       value: 1,
   };
   let c2 = PokerCard {
       suit: PokerSuit::Diamonds,
       value: 12,
   };
}
</code></pre></pre>
<p>这段代码很好的完成了它的使命，通过结构体<code>PokerCard</code>来代表一张牌，结构体的<code>suit</code>字段表示牌的花色，类型是<code>PokerSuit</code>枚举类型，<code>value</code>字段代表扑克牌的值。</p>
<p>可以吗？可以！好吗？说实话，不咋地，因为还有简洁的多的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust">enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(13);
}
</code></pre></pre>
<p>直接将数据信息关联到枚举成员上，直接省去近一半的代码，这种实现漂亮不？</p>
<p>而且不仅仅如此，同一个枚举类型下的不同成员还能持有不同的类型，例如让部分花色打印1-13的字样，另外花色打印上A-K的字样:</p>
<pre><pre class="playground"><code class="language-rust">enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(char),
    Hearts(char),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds('A');
}
</code></pre></pre>
<p>回想一下，遇到这种不同类型的情况，再用我们之前的结构体实现方式，可行吗？也许可行，但是会复杂很多。</p>
<p>再来看一个来自标准库中的例子:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>该例子跟我们之前的扑克牌很像，只不过枚举成员包含的类型更复杂了，变成了结构体：分别通过<code>Ipv4Addr</code>和<code>Ipv4Addr</code>来定义两种不同的IP数据。</p>
<p>从这些例子可以看出，<strong>任何类型的数据都可以放入枚举成员中</strong>: 例例如字符串、数值、结构体甚至另一个枚举。</p>
<p>增加一些挑战？先看以下代码：</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}
</code></pre></pre>
<p>该枚举类型代表一条消息，它包含四个不同的成员:</p>
<ul>
<li><code>Quit</code> 没有任何关联数据</li>
<li><code>Move</code> 包含一个匿名结构体</li>
<li><code>Write</code> 包含一个<code>String</code>字符串</li>
<li><code>ChangeColor</code>包含三个<code>i32</code></li>
</ul>
<p>当然，我们也可以用结构体的方式来定义这些消息：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QuitMessage; // 元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
<span class="boring">}
</span></code></pre></pre>
<p>由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受4个不同的结构体作为参数。</p>
<p>而且从代码规范角度来看，枚举的实现更简洁，代码内聚性更强，不像结构体的实现，分散在各个地方。</p>
<p>最后，再用一个实际项目中的设计考虑，来结束枚举类型的语法学习。</p>
<p>例如我们有一个web服务，需要接受用户的长连接，假设连接有两种：TcpStream和TlsStream，但是我们希望对这两个连接的处理流程相同，也就是用同一个函数来处理这两个连接，代码如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>func new (stream: TcpStream) {
  let mut s = stream;
  if tls {
    s = negotiate_tls(stream)
  }
  
  // websocket是一个WebSocket&lt;TcpStream&gt;或者
  //   WebSocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;类型
  websocket = WebSocket::from_raw_socket(
    stream, ......)
}
<span class="boring">}
</span></code></pre></pre>
<p>此时，枚举类型就能帮上大忙：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Websocket {
  Tcp(Websocket&lt;TcpStream&gt;),
  Tls(Websocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="option枚举用于处理空值"><a class="header" href="#option枚举用于处理空值">Option枚举用于处理空值</a></h2>
<p>在其它编程语言中，往往都有一个<code>null</code>关键字，该关键字用于表明一个变量当前的值为空(不是零值，例如整形的零值是0)，也就是不存在值。当你对这些<code>null</code>进行操作时，例如调用一个方法，就会直接抛出异常，导致程序的崩溃，因此我们在编程时需要格外的小心去处理这些<code>null</code>空值。</p>
<blockquote>
<p>Tony Hoare，null的发明者，曾经说过有非常有名的话</p>
<p>我称之为我十亿美元的错误。当时，我在使用一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过在设计过程中，我未能抵抗住诱惑，引入了空引用的概念，因为它非常容易实现。就是因为这个决策，引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。</p>
</blockquote>
<p>然后空值的表达依然非常有意义，因为空值表示当前时刻变量的值是缺失的。因此，Rust吸取了众多教训，决定抛弃<code>null</code>,而改为使用<code>Option</code>枚举变量来表述这种结果：
**一个变量要么有值:<code>Some(T)</code>, 要么为空: <code>None</code>，定义如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>T</code>是泛型参数，<code>Some(T)</code>表示该枚举成员的数据类型是<code>T</code>, 换句话说，<code>Some</code>可以包含任何类型的数据。</p>
<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了<code>prelude</code>(Rust会将最常用的类型、函数等提前引入进来，避免我们再手动引入)之中，你不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要<code>Option::</code>前缀来直接使用<code>Some</code> 和 <code>None</code>。即便如此<code>Option&lt;T&gt;</code> 也仍是常规的枚举，<code>Some(T)</code> 和 <code>None</code> 仍是 <code>Option&lt;T&gt;</code> 的成员。</p>
<p>再来看以下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>如果使用 <code>None</code> 而不是 <code>Some</code>，需要告诉 Rust <code>Option&lt;T&gt;</code> 是什么类型的，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 成员保存的值的类型。</p>
<p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T&gt;</code> 为什么就比空值要好呢？</p>
<p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code>(<code>Option&lt;T&gt;</code>) 与 <code>i8</code>(<code>T</code>) 相加：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}
</span></code></pre></pre>
<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>很好！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>不再担心会错误的使用一个空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 <code>Option&lt;T&gt;</code> 的值时，如何从 <code>Some</code> 成员中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T&gt;</code> 枚举拥有大量用于各种情况的方法：你可以查看<a href="https://doc.rust-lang.org/std/option/enum.Option.html">它的文档</a>。熟悉 <code>Option&lt;T&gt;</code> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 <code>Option&lt;T&gt;</code> 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
<p>这里先简单看一下<code>match</code>的大致模样，在<a href="basic/compound-type/../match-pattern.html">模式匹配</a>中，我们会详细讲解:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><code>plus_one</code>通过<code>match</code>来处理不同<code>Option</code>的情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>在日常开发中，使用最广的数据结构之一就是数组，在Rust中，最常用的数组有两个，第一个是长度固定且很快速的<code>array</code>，第二个是可动态增长的但是有一点性能损耗的<code>Vector</code>，在本书中，我们称呼<code>array</code>为数组，<code>Vector</code>为动态数组。</p>
<p>不知道你们发现没，这两个数组的关系跟<code>&amp;str</code>与<code>String</code>的关系很像，前者是长度固定的字符串切片，后者是可动态增长的字符串。其实，在Rust中无论是<code>String</code>还是<code>Vector</code>，它们都是Rust的高级类型：集合类型，在后面章节会有详细介绍。</p>
<p>对于本章节，我们的重点还是放在数组<code>array</code>上。数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。结合上面的内容，可以得出数组的三要素：</p>
<ul>
<li>长度固定</li>
<li>元素必须有相同的类型</li>
<li>依次线性排列</li>
</ul>
<p>这里再啰嗦一句，<strong>我们这里说的数组是Rust的基本类型，因此长度是固定的，这个跟其他编程语言不同，而其它编程语言的数组往往对应的是Rust中的动态数组<code>Vector</code></strong>，希望读者大大牢记此点。</p>
<h3 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h3>
<p>在Rust中，数组是这样定义的：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>数组语法跟<code>javascript</code>很像，也跟大多数编程语言很像。由于它的元素类型大小固定，且长度也是固定，因此<strong>数组是存储在栈上</strong>，性能也会非常优秀。与此对应，动态数组<code>Vector</code>是存储在堆上，因此长度可以动态改变。当你不确定是使用数组还是动态数组时，那就应该使用后者，具体见[动态数组Vector]一章.</p>
<p>举个例子，在需要知道一年中各个月份名称的程序中，你很可能希望使用的是数组而不是动态数组。因为月份是固定的，它总是包含 12 个元素：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>在一些时候，还需要为<strong>数组声明类型</strong>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>这里，数组类型是通过方括号语法声明，<code>i32</code>是元素类型，分号后面的数字<code>5</code>是数组长度，数组类型也从侧面说明了<strong>数组的元素类型要统一，长度要固定</strong>.</p>
<p>还可以使用下面的语法初始化一个<strong>某个值重复出现N次的数组</strong>: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p><code>a</code>数组包含<code>5</code>个元素,这些元素的初始化值为<code>3</code>，聪明的读者已经发现，这种语法跟数组类型的声明语法其实是保持一致的：<code>[3;5]</code> 和<code>[类型;长度]</code>.</p>
<p>在元素重复的场景，这种写法要简单的多，否则你就得疯狂敲击键盘：<code>let a = [3, 3, 3, 3, 3];</code>,不过老板可能很喜欢你的这种疯狂编程的状态。</p>
<h3 id="访问数组元素"><a class="header" href="#访问数组元素">访问数组元素</a></h3>
<p>因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [9, 8, 7, 6, 5];

    let first = a[0]; // 获取a数组第一个元素
    let second = a[1]; // 获取第二个元素
}
</code></pre></pre>
<p>此处，<code>first</code>获取到的值是<code>9</code>,<code>second</code>是<code>8</code>。</p>
<h4 id="越界访问"><a class="header" href="#越界访问">越界访问</a></h4>
<p>假如使用超出数组范围的索引访问数组元素，就发生什么？下面是一个接收用户的控制台输入，然后用于访问数组元素的例子：</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();
    // 读取控制台的输出
    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(
        &quot;The value of the element at index {} is: {}&quot;,
        index, element
    );
}
</code></pre></pre>
<p>使用<code>cargo run</code>来运行代码，因为数组只有5个元素，如果我们试图输入<code>5</code>去访问第<code>6</code>个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：</p>
<pre><code class="language-console">Please enter an array index.
5
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>这就是数组访问越界，访问了数组中不存在的元素，导致Rust运行时错误。程序因此退出并显示错误消息，未执行最后的<code>println!</code>语句。</p>
<p>当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust会出现 panic。这种检查必须在运行时进行，尤其是在这种情况下，因为编译器无法在编译期知道用户之后运行代码时将输入什么值。</p>
<p>这种就是Rust的安全特性之一。在很多系统编程语言中，并不会检查数组越界问题，你会访问到无效的内存地址获取到一个风马牛不相及的值，最终导致在程序逻辑上出现大问题，而且这种问题会非常难以检查。</p>
<h2 id="数组切片"><a class="header" href="#数组切片">数组切片</a></h2>
<p>在之前的<a href="basic/compound-type/./string-slice.html#%E5%88%87%E7%89%87(slice)">章节</a>，我们有讲到<code>切片</code>这个概念,它允许你引用集合中的某个连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &amp;[i32] = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>上面的数组切片<code>slice</code>的类型是<code>&amp;[i32]</code>,与之对比，数组的类型是<code>[i32;5]</code>，简单总结下切片的特点：</p>
<ul>
<li>切片的长度与数组不同，并不是固定的，而是取决于你使用时指定的开始和结束位置</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li>
<li>切片类型[T]拥有不固定的大小，而切片引用类型&amp;[T]则具有固定的大小，因为Rust很多时候都需要固定大小数据类型，因此&amp;[T]更有用,<code>&amp;str</code>字符串切片也同理</li>
</ul>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>最后，让我们以一个综合性使用数组的例子，来结束本章节的学习：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  // 编译器自动推导出one的类型
  let one             = [1, 2, 3];
  // 显式类型标注
  let two: [u8; 3]    = [1, 2, 3];
  let blank1          = [0; 3];
  let blank2: [u8; 3] = [0; 3];
    
  // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]
  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];
  
  // 借用arrays的元素用作循环中
  for a in &amp;arrays {
    print!(&quot;{:?}: &quot;, a);
    // 将a变成一个迭代器，用于循环
    // 你也可以直接用for n in a {}来进行循环
    for n in a.iter() {
      print!(&quot;\t{} + 10 = {}&quot;, n, n+10);
    }
 
    let mut sum = 0;
    // 0..a.len,是一个Rust的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1
    for i in 0..a.len() {
      sum += a[i];
    }
    println!(&quot;\t({:?} = {})&quot;, a, sum);
  }
}
</code></pre></pre>
<p>做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：</p>
<ul>
<li><strong>数组类型容易跟数组切片混淆</strong>,[T;n]描述了一个数组的类型，而[T]描述了切片的类型, 因为切片是运行期的数据结构，因此它不具备编译器的长度，因此不能用[T;n]的形式去描述</li>
<li><code>[u8; 3]</code>和<code>[u8;4]是不同的类型</code>，数组的长度也是类型的一部分</li>
<li><strong>在实践中，使用最多的是数组切片[T]</strong>，我们往往通过引用的方式去使用<code>&amp;[T]</code>,因为后者有固定的类型大小.</li>
</ul>
<p>至此，关于数据类型部分，我们已经全部学完了，对于Rust学习而言，我们也迈出了坚定的第一步，后面将开始对更高级特性的学习。未来如果大家有疑惑需要检索知识，一样可以继续回顾过往的章节，因为本书不仅仅是一门Rust的教程，还是一本厚重的Rust工具书。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h1>
<p>80后应该都对学校的小混混记忆犹新，在那个时代，小混混们往往都认为自己是地下王者，管控着地下事务的流程，在我看来，他们就像代码中的流程控制一样，无处不在，很显眼，但是又让人懒得重视。</p>
<p>言归正传，Rust程序是从上而下顺序执行的，在此过程中，我们可以引入循环、分支等流程控制方式，帮助我们的代码更好的实现相应的功能。</p>
<h2 id="使用if来做分支控制"><a class="header" href="#使用if来做分支控制">使用if来做分支控制</a></h2>
<blockquote>
<p>if else无处不在 - <code>鲁迅说</code></p>
</blockquote>
<p>但凡你能找到一门编程语言没有<code>if else</code>，那么一定更要反馈给鲁迅，反正不是我说的:) 总之，只要你拥有其它语言的编程经验，就一定会有以下认知：<code>if else</code><strong>表达式</strong>允许根据条件执行不同的代码分支：</p>
<pre><pre class="playground"><code class="language-rust">if condition == true {
    // A...
} else {
    // B...
}
该代码读作：若`condition`条件为`true`，则执行`A`代码，否则执行`B`代码.

先看下面代码：
```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p>以上代码有以下几点要注意：</p>
<ul>
<li><strong><code>if</code>语句块是表达式</strong>: 因此它可以返回一个值，这里我们使用<code>if</code>的返回值来给<code>number</code>进行赋值，因此<code>number</code>的值是<code>5</code>。</li>
<li>用<code>if</code>来赋值时，要保证每个分支返回的类型一样，此处返回的<code>5</code>和<code>6</code>就是同一个类型，如果返回类型不一致就会报错：</li>
</ul>
<pre><code class="language-console">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integer, found &amp;str // 期望整数类型，但却发现&amp;str字符串切片
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<h4 id="使用else-if来处理多重条件"><a class="header" href="#使用else-if来处理多重条件">使用else if来处理多重条件</a></h4>
<p>可以将<code>else if</code>与<code>if</code>、<code>else</code>组合在一起实现多种条件分支判断:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n = 6;

    if n % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if n % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if n % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出<code>if</code>语句块，最终本程序会匹配执行<code>else if n % 3 == 0</code>的分支，输出<code>&quot;number is divisible by 3&quot;</code>。</p>
<p>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！</p>
<p>如果代码中有大量的<code>else if </code>会让代码变得极其丑陋，因此在下一章，我们引入一个<code>match</code>关键字，用以解决多分支模式匹配的问题。</p>
<h2 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h2>
<p>循环无处不在，上到数钱，下到数年，你能想象的很多场景都存在循环，因此它也是流程控制中最重要的组成部分之一.</p>
<p>在Rust语言中有三种循环方式：<code>for</code>、<code>while</code>和<code>loop</code>，其中<code>for</code>循环是Rust循环王冠上的明珠。</p>
<h4 id="for循环"><a class="header" href="#for循环">for循环</a></h4>
<p><code>for</code>循环是Rust处理迭代的大杀器，当我们迭代数据集合时，往往就用<code>for</code>：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 1..=5 {
        println!(&quot;{}&quot;,i);
    }
}
</code></pre></pre>
<p>以上代码迭代输出一个从1到5的序列，简单粗暴，核心就在于<code>for</code>和<code>in</code>的联动，语义表达如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for 元素 in 集合 {
  // 使用元素干一些你懂我不懂的事情
}
<span class="boring">}
</span></code></pre></pre>
<p>这个语法跟<code>javascript</code>还是蛮像的，应该挺好理解。</p>
<p>注意，使用<code>for</code>我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合(不使用引用的话，所有权会被转移到<code>for</code>语句块中):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in &amp;container {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>如果想在循环中，<strong>修改该元素</strong>，使用<code>mut</code>关键字：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in &amp;mut collection {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>总结如下：</p>
<table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr>
<tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr>
<tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr>
</tbody></table>
<p>如果想在循环中<strong>获取元素的索引</strong>：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [4,3,2,1];
    // `.iter()`方法把`a`数组变成一个迭代器
    for (i,v) in a.iter().enumerate() {
        println!(&quot;第{}个元素是{}&quot;,i+1,v);
    }
}
</code></pre></pre>
<p>有同学可能会想到，如果我们要用<code>for</code>循环控制某个过程执行10次，但是又不关心那个计数值，该怎么写？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for _ in 0..10 {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>可以用<code>_</code>来替代<code>i</code>用于<code>for</code>循环中，在Rust中<code>_</code>的含义是忽略该值或者类型的意思，如果不使用<code>_</code>,那么编译器会给你一个<code>变量未使用的</code>的警告.</p>
<p><strong>两种循环方式优劣对比</strong></p>
<p>以下代码，我们实现了两种循环方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
<span class="boring">}
</span></code></pre></pre>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环迭代集合中的元素，优劣如下：</p>
<ul>
<li><strong>性能</strong>：第一种使用方式中<code>collection[index]</code>的索引访问，会因为边界检查(bounds checking)导致运行时的性能损耗 - Rust会检查并确认<code>index</code>是落在集合内也就是合法的，但是第二种直接迭代的方式就不会触发这种检查,因为编译器会在编译时就完成分析并证明这种访问是合法的`</li>
<li><strong>安全</strong>: 第一种方式里对<code>collection</code>的索引访问是非连续的，存在一定可能性在两次访问之间，<code>collection</code>发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险</li>
</ul>
<p>由于for循环无需任何条件限制，也不需要通过索引来访问，因此是最安全也是最常用的，在下面的<code>while</code>中，我们能看到为什么<code>for</code>会更加安全。</p>
<h4 id="continue"><a class="header" href="#continue"><code>continue</code></a></h4>
<p>使用<code>continue</code>可以跳过当前当次的循环，开始下次的循环:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> for i in 1..4 {
     if i == 2 {
         continue;
     }
     println!(&quot;{}&quot;,i);
 }
<span class="boring">}
</span></code></pre></pre>
<p>上面代码对1到3的序列进行迭代，且跳过值为2时的循环，输出如下：</p>
<pre><code class="language-console">1
3
</code></pre>
<h4 id="while循环"><a class="header" href="#while循环">while循环</a></h4>
<p>如果你需要一个条件来循环，当该条件为<code>true</code>时，继续循环，条件为<code>false</code>，跳出循环，那么<code>while</code>就非常适用: </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut n = 0;

    while n &lt;= 5  {
        println!(&quot;{}!&quot;, n);

        n = n + 1;
    }

    println!(&quot;我出来了！&quot;);
}
</code></pre></pre>
<p>该<code>while</code>循环，只有到<code>n</code>小于等于<code>5</code>时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从<code>0</code>开始，满足条件，进行循环，然后是<code>1</code>，满足条件，进行循环，最终到<code>6</code>的时候，不满足条件，跳出<code>while</code>循环，执行<code>我出来了</code>的打印，然后程序结束：</p>
<pre><code class="language-console">0!
1!
2!
3!
4!
5!
我出来了！
</code></pre>
<p>当然，你也可以用其它方式组合实现，例如<code>loop</code>(无条件循环，将在下面介绍) + <code>if</code> + <code>break</code>: </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut n = 0;

    loop {
        if n &gt; 5 {
            break
        }
        println!(&quot;{}&quot;,n);
        n+=1;
    }

    println!(&quot;我出来了！&quot;);
}
</code></pre></pre>
<p>可以看出，在这种循环场景下，<code>while</code>要简洁的多。</p>
<p><strong>while vs for</strong></p>
<p>我们也能用<code>while</code>来实现<code>for</code>的功能：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p>这里，代码对数组中的元素进行计数。它从索引 <code>0</code> 开始，并接着循环直到遇到数组的最后一个索引（这时，<code>index &lt; 5</code> 不再为真）。运行这段代码会打印出数组中的每一个元素：</p>
<pre><code class="language-console">the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>数组中的所有五个元素都如期被打印出来。尽管 index 在某一时刻会到达值 5，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。</p>
<p>但这个过程很容易出错；如果索引长度不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。</p>
<p><code>for</code>循环代码如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p>可以看出，<code>for</code>并不会使用索引去访问数组，因此更安全也更简洁，同时避免<code>运行时的边界检查</code>，性能更高。</p>
<h4 id="loop循环"><a class="header" href="#loop循环">loop循环</a></h4>
<p>对于循环而言，<code>loop</code>循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景(虽然能用，但是在很多场景下，<code>for</code>和<code>while</code>才是最优选择)，因为loop就是一个简单的无限循环，你可以在内部实现逻辑通过<code>break</code>关键字来控制循环何时结束。</p>
<p>使用<code>loop</code>循环一定要打起精神，否则你会写出下面的跑满你一个cpu核心的疯子代码：</p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>该循环会不停的在终端打印输出，直到你使用<code>Ctrl-C</code>结束程序：</p>
<pre><code class="language-console">again!
again!
again!
again!
^Cagain!
</code></pre>
<p><strong>注意</strong>，不要轻易尝试上述代码，如果你电脑配置不行，可能会死机！！！</p>
<p>因此，当使用<code>loop</code>时，必不可少的伙伴是<code>break</code>关键字，它能让循环在满足某个条件时跳出：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre></pre>
<p>以上代码当<code>counter</code>递增到<code>10</code>时，就会通过<code>break</code>返回一个<code>counter*2</code>的值，最后赋给result并打印出来。</p>
<p>这里有几点值得注意：</p>
<ul>
<li><strong>break可以单独使用，也可以带一个返回值</strong>,有些类似<code>return</code></li>
<li><strong>loop是一个表达式</strong>，因此可以返回一个值</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h1>
<p>模式匹配，这个词，对于非函数语言编程来说，真的还蛮少听到，因为它经常出现在函数式编程里，用于为复杂的类型系统提供一个轻松的解构能力.</p>
<p>曾记否？在枚举和流程控制那章，我们遗留了两个问题，都是关于<code>match</code>的，第一个是如何对<code>Option</code>枚举进行进一步处理，另外一个就是如何用<code>match</code>来替代<code>else if</code>这种丑陋的多重分支使用方式，那么让我们先一起来揭开<code>match</code>的神秘面纱。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match和if-let"><a class="header" href="#match和if-let">match和if let</a></h1>
<p>先来看一个关于<code>match</code>的简单例子:</p>
<pre><pre class="playground"><code class="language-rust">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; {
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(&quot;West&quot;),
    };
}
</code></pre></pre>
<p>这里我们想去匹配<code>dire</code>对应的枚举类型，因此在match中用三个匹配分支来完全覆盖枚举变量<code>Direction</code>的所有成员类型，有以下几点值得注意：</p>
<ul>
<li><code>match</code>的匹配必须要穷举出所有可能,因此这里用<code>_</code>来代表其余的所有可能性</li>
<li><code>match</code>的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li>
<li><strong>X | Y</strong>, 是逻辑运算符<code>或</code>,代表该分支可以匹配<code>X</code>也可以匹配<code>Y</code>，只要满足一个即可</li>
</ul>
<p>其实<code>match</code>跟其他语言中的<code>switch</code>非常像,例如<code>_</code>类似<code>switch</code>中的<code>default</code>。</p>
<h2 id="match匹配"><a class="header" href="#match匹配"><code>match</code>匹配</a></h2>
<p><code>match</code>允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码，下面让我们来一一详解，先看一个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt;  {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>value_in_cents</code>函数根据匹配到的硬币类似，返回对应的美分数值，<code>match</code>后紧跟着的是一个表达式，跟<code>if</code>很像，但是<code>if</code>后的表达式必须是一个布尔值，而<code>match</code>后的表达式返回值可以是任意类型，只要能跟后面的分支匹配起来即可，这里的<code>coin</code>是枚举<code>Coin</code>类型。</p>
<p>接下来是<code>match</code>的分支。一个分支有两个部分：一个模式和针对该模式的处理代码。第一个分支的模式是<code>Coin::Penny</code>而之后的<code>=&gt;</code>运算符将模式和将要运行的代码分开。这里的代码就仅仅是表达式<code>1</code>, 不同分支之间使用逗号分隔。</p>
<p>当<code>match</code>表达式执行时，它将目标值<code>coin</code>按顺序与每一个分支的模式相比较, 如果模式匹配了这个值，那么模式之后的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 match 表达式的返回值。如果分支有多行代码，那么需要用<code>{}</code>包裹，同时最后一行代码需要是一个表达式。</p>
<h4 id="使用match表达式赋值"><a class="header" href="#使用match表达式赋值">使用<code>match</code>表达式赋值</a></h4>
<p>还有一点很重要，<code>match</code>本身也是一个表达式，因此可以用它来赋值：</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    // let d_panic = Direction::South;
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 =&gt; &quot;127.0.0.1&quot;,
        _ =&gt; &quot;::1&quot;,
    };

    println!(&quot;{}&quot;, ip_str);
}
</code></pre></pre>
<p>这里因为匹配到<code>_</code>分支，因此将<code>&quot;::1&quot;</code>赋值给了<code>ip_str</code>.</p>
<h4 id="模式绑定"><a class="header" href="#模式绑定">模式绑定</a></h4>
<p>匹配分支的另外一个重要功能是从模式中取出绑定的值，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 25美分硬币
}
<span class="boring">}
</span></code></pre></pre>
<p>其中Coin::Quarter成员还存放了一个值：美国的某个州，因为在1999年到2008年间，美国在25美分(Quater)硬币的背后为50个州印刷了不同的设计。其它硬币都没有相关的设计。</p>
<p>接下来，我们希望在模式匹配中，获取到25美分硬币上刻印的州的名称：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; { 
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中，在匹配<code>Coin::Quarter</code>模式时，我们把它内部存储的值绑定到了<code>state</code>变量上，因此<code>state</code>变量就是对应的<code>UsState</code>枚举类型。</p>
<p>例如有一个印了阿拉斯加州标记的25分硬币：<code>Coin::Quarter(UsState::Alaska))</code>, 它在匹配时，<code>state</code>变量将被绑定<code>UsState::Alaska</code>的枚举值。</p>
<p>再来看一个更复杂的例子：</p>
<pre><pre class="playground"><code class="language-rust">enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [ 
        Action::Say(&quot;Hello Rust&quot;.to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) =&gt; {
                println!(&quot;{}&quot;, s);
            },
            Action::MoveTo(x, y) =&gt; {
                println!(&quot;point from (0, 0) move to ({}, {})&quot;, x, y);
            },
            Action::ChangeColorRGB(r, g, _) =&gt; {
                println!(&quot;change color into '(r:{}, g:{}, b:0)', 'b' has been ignored&quot;,
                    r, g,
                );
            }
        }
    }
}
</code></pre></pre>
<p>运行后输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running `target/debug/world_hello`
Hello Rust
point from (0, 0) move to (1, 2)
change color into '(r:255, g:255, b:0)', 'b' has been ignored
</code></pre>
<h4 id="穷尽匹配"><a class="header" href="#穷尽匹配">穷尽匹配</a></h4>
<p>在文章的开头，我们简单总结过<code>match</code>的匹配必须穷尽所有情况，下面来举例说明，例如:</p>
<pre><pre class="playground"><code class="language-rust">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; {
            println!(&quot;South or North&quot;);
        },
    };
}
</code></pre></pre>
<p>我们没有处理<code>Direction::West</code>的情况，因此会报错：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0004]: non-exhaustive patterns: `West` not covered // 非穷尽匹配，`West`没有被覆盖
  --&gt; src/main.rs:10:11
   |
1  | / enum Direction {
2  | |     East,
3  | |     West,
   | |     ---- not covered
4  | |     North,
5  | |     South,
6  | | }
   | |_- `Direction` defined here
...
10 |       match dire {
   |             ^^^^ pattern `West` not covered // 模式`West`没有被覆盖
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Direction`
<span class="boring">}
</span></code></pre></pre>
<p>首先，不禁想感叹，<code>Rust</code>的编译器真**强大，忍不住爆粗口了，sorry，如果你以后进一步深入使用Rust也会像我这样感叹的。</p>
<p>其次，Rust知道<code>match</code>中没有覆盖的具体分支，甚至知道哪些模式被遗忘了。这种设计初心是为了保证我们处理所有的情况，特别是那种会造成十亿美金的空值问题。</p>
<h4 id="_-通配符"><a class="header" href="#_-通配符"><code>_</code> 通配符</a></h4>
<p>Rust 也提供了一个<strong>模式</strong>用于不想列举出所有可能值的场景。例如，<code>u8</code> 可以拥有 0 到 255 的有效的值，如果我们只关心 1、3、5 和 7 这几个值，就并不想列出其它的 0、2、4、6、8、9 一直到 255 的值。所幸, 我们不必这么做, 因为可以使用使用特殊的模式 <code>_</code> 替代：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>通过将其放置于其他分支后，<code>_</code>将会匹配所有遗漏的值。<code>()</code>表示啥都不做的意思，所以当匹配到<code>_</code>后，什么也不会发生。</p>
<p>然后，在某些场景下，我们其实只关心<strong>某一个值是否存在</strong>，此时<code>match</code>就显得过于啰嗦，还好，Rust提供了<code>if let</code>.</p>
<h2 id="if-let匹配"><a class="header" href="#if-let匹配"><code>if let</code>匹配</a></h2>
<p>很多时候都会遇到只有一个模式的值需要被处理，其它值直接忽略的场景，用<code>match</code>处理如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = Some(3u8);
    match v{
        Some(3) =&gt; println!(&quot;three&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p>我们想要对 <code>Some(3)</code> 模式进行匹配, 同时不想处理任何其他 <code>Some&lt;u8&gt;</code> 值或 <code>None</code> 值。但是为了满足<code>match</code>表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样也要增加很多样板代码。</p>
<p>杀鸡焉用牛刀，可以用<code>if let</code>的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好: <strong>当你只要匹配一个条件，且忽略其他条件时就用<code>if let</code>，否则都用match</strong>.</p>
<h2 id="变量覆盖"><a class="header" href="#变量覆盖">变量覆盖</a></h2>
<p>无论是是<code>match</code>还是<code>if let</code>，他们都可以在模式匹配时覆盖掉老的值，绑定新的直:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let age = Some(30);
   println!(&quot;在匹配前，age是{:?}&quot;,age);
   if let Some(age) = age {
       println!(&quot;匹配出来的age是{}&quot;,age);
   }

   println!(&quot;在匹配后，age是{:?}&quot;,age);
}
</code></pre></pre>
<p><code>cargo run</code>运行后输出如下：</p>
<pre><code class="language-console">在匹配前，age是Some(30)
匹配出来的age是30
在匹配后，age是Some(30)
</code></pre>
<p>可以看出在<code>if let</code>中，<code>=</code>右边<code>Some(i32)</code>类型的<code>age</code>被左边<code>i32</code>类型的新<code>age</code>覆盖了，该覆盖一直持续到<code>if let</code>语句块的结束。因此第三个<code>println!</code>输出的<code>age</code>依然是<code>Some(i32)</code>类型。</p>
<p>对于<code>match</code>类型也是如此:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let age = Some(30);
   println!(&quot;在匹配前，age是{:?}&quot;,age);
   match age {
       Some(age) =&gt;  println!(&quot;匹配出来的age是{}&quot;,age),
       _ =&gt; ()
   }
   println!(&quot;在匹配后，age是{:?}&quot;,age);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解构option"><a class="header" href="#解构option">解构Option</a></h1>
<p>在枚举那一章，提到过<code>Option</code>枚举变量是用来解决Rust中一个变量是否有值的问题，定义如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>总而言之，<strong>一个变量要么有值:<code>Some(T)</code>, 要么为空: <code>None</code></strong>.</p>
<p>那么现在的问题就是该如何去使用这个<code>Option</code>枚举类型，根据我们上一节的经验，可以通过<code>match</code>来实现。</p>
<h2 id="匹配-optiont"><a class="header" href="#匹配-optiont">匹配 <code>Option&lt;T&gt;</code></a></h2>
<p>使用<code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况，为了演示这一点，下面一起来编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code>，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 <code>None</code> 值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><code>plus_one</code>接受一个<code>Option&lt;i32&gt;</code>类型的参数，同时返回一个<code>Option&lt;i32&gt;</code>类型的值(这种形式的函数在标准库内随处所见)，在该函数的内部处理中，如果传入的是一个<code>None</code>，则返回一个<code>None</code>切不做任何处理；如果传入的是一个<code>Some(i32)</code>，则通过模式绑定，把其中的值绑定到变量<code>i</code>上，然后返回<code>i+1</code>的值，同时用<code>Some</code>进行包裹。</p>
<p>进一步说明，假设<code>plus_one</code>函数接受的参数值x是<code>Some(5)</code>，那么接着我们将<code>x</code>与各个分支进行比较。</p>
<h4 id="传入参数some5"><a class="header" href="#传入参数some5">传入参数<code>Some(5)</code></a></h4>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>首先是<code>None</code>分支，因为值<code>Some(5)</code> 并不匹配模式 <code>None</code>，所以继续匹配下一个分支。</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5)</code> 与 <code>Some(i)</code> 匹配吗？当然匹配！它们是相同的成员。<code>i</code> 绑定了 <code>Some</code> 中包含的值，所以 <code>i</code> 的值是 <code>5</code>。接着匹配分支的代码被执行，所以我们将 <code>i</code> 的值加一并返回一个含有值 <code>6</code> 的新 <code>Some</code>。</p>
<h4 id="传入参数none"><a class="header" href="#传入参数none">传入参数None</a></h4>
<p>接着考虑下<code>plus_one</code> 的第二个调用，这次传入的<code>x</code> 是<code>None</code>。我们进入 <code>match</code> 并与第一个分支相比较。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>匹配上了！接着程序继续执行该分支后的代码：返回表达式<code>None</code>的值，也就是返回一个<code>None</code>，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式和匹配"><a class="header" href="#模式和匹配">模式和匹配</a></h1>
<h2 id="模式"><a class="header" href="#模式">模式</a></h2>
<p>模式是Rust中的特殊语法，它用来匹配类型中的结构和数据，它往往和<code>match</code>表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<h3 id="所有可能用到模式的地方"><a class="header" href="#所有可能用到模式的地方">所有可能用到模式的地方</a></h3>
<h4 id="match分支"><a class="header" href="#match分支">match分支**</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，<code>match</code>的每个分支就是一个<strong>模式</strong>，因为<code>match</code>匹配是穷尽式的，因此我们往往需要一个特殊的模式<code>_</code>，来匹配剩余的所有情况：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    _ =&gt; EXPRESSION,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="if-let分支"><a class="header" href="#if-let分支">if let分支</a></h4>
<p><code>if let</code>往往用于匹配一个模式，而忽略剩下的所有模式的场景：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Pattern = SOME_VALUE {

}
<span class="boring">}
</span></code></pre></pre>
<h4 id="while-let条件循环"><a class="header" href="#while-let条件循环">while let条件循环</a></h4>
<p>一个与 <code>if let</code> 结构类似的是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。下面展示了一个使用<code>while let</code>的例子:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
<span class="boring">}
</span></code></pre></pre>
<p>这个例子会打印出 <code>3</code>、<code>2</code> 接着是 <code>1</code>。<code>pop</code> 方法取出动态数组的最后一个元素并返回 <code>Some(value)</code>,如果动态数组是空的，它返回 <code>None</code>。对于<code>while</code>来说，只要 <code>pop</code> 返回 <code>Some</code> 就会一直不停的循环。一旦其返回 <code>None``，while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p>
<p>你也可以用<code>loop</code> + <code>if let</code> 或者<code>match</code>来实现，但是会更加啰嗦。</p>
<h4 id="for循环-1"><a class="header" href="#for循环-1">for循环</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
<span class="boring">}
</span></code></pre></pre>
<p>这里使用 <code>enumerate</code> 方法产生一个迭代器，该迭代器每次迭代会返回一个<code>(索引，值)</code>形式的元组，同时用<code>(index,value)</code>来匹配。</p>
<h4 id="let语句"><a class="header" href="#let语句">let语句</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let PATTERN = EXPRESSION;
<span class="boring">}
</span></code></pre></pre>
<p>是的，这个语句我们已经用了无数次了，它也是一种模式匹配:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>这其中，<code>x</code>也是一种模式绑定，代表将<strong>匹配的值绑定到变量x上</strong>.因此，在Rust中,<strong>变量名也是一种模式</strong>,只不过它比较朴素很不起眼罢了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p>上面将一个元组与模式进行匹配(<strong>模式和值的类型比较相同！</strong>)，然后把<code>1,2,3</code>分别绑定到<code>x,y,z</code>上。</p>
<p>因为模式匹配要求两边的类型必须相同，导致了下面的代码会报错：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p>因为对于元组来说，元素个数也是类型的一部分！</p>
<h4 id="函数参数-1"><a class="header" href="#函数参数-1">函数参数</a></h4>
<p>函数参数也是模式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: i32) {
    // 代码
}
<span class="boring">}
</span></code></pre></pre>
<p>其中<code>x</code>就是一个模式，你还可以在参数中匹配元组：</p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><code>&amp;(3,5)</code>会匹配模式<code>&amp;(x,y)</code>,因此<code>x</code>得到了<code>3</code>，<code>y</code>得到了<code>5</code>.</p>
<h4 id=""><a class="header" href="#"></a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全模式列表"><a class="header" href="#全模式列表">全模式列表</a></h1>
<p>在本书中我们已领略过许多不同类型模式的例子。在本节中，我们收集了模式中所有有效的语法，并讨论了为什么可能要使用每个语法。</p>
<h3 id="匹配字面值"><a class="header" href="#匹配字面值">匹配字面值</a></h3>
<p>如第六章所示，可以直接匹配字面值模式。如下代码给出了一些例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码会打印 <code>one</code> 因为 <code>x</code> 的值是 1。如果希望代码获得特定的具体值，则该语法很有用。</p>
<h3 id="匹配命名变量"><a class="header" href="#匹配命名变量">匹配命名变量</a></h3>
<p>命名变量是匹配任何值的不可反驳模式，这在之前已经使用过数次。然而当其用于 <code>match</code> 表达式时情况会有些复杂。因为 <code>match</code> 会开始一个新作用域，<code>match</code> 表达式中作为模式的一部分声明的变量会覆盖 <code>match</code> 结构之外的同名变量，与所有变量一样。在示例 18-11 中，声明了一个值为 <code>Some(5)</code> 的变量 <code>x</code> 和一个值为 <code>10</code> 的变量 <code>y</code>。接着在值 <code>x</code> 上创建了一个 <code>match</code> 表达式。观察匹配分支中的模式和结尾的 <code>println!</code>，并在运行此代码或进一步阅读之前推断这段代码会打印什么。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">示例 18-11: 一个 <code>match</code> 语句其中一个分支引入了覆盖变量 <code>y</code></span></p>
<p>让我们看看当 <code>match</code> 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 <code>x</code> 中定义的值，所以代码继续执行。</p>
<p>第二个匹配分支中的模式引入了一个新变量 <code>y</code>，它会匹配任何 <code>Some</code> 中的值。因为我们在 <code>match</code> 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 <code>y</code>。这个新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值。因此这个 <code>y</code> 绑定了 <code>x</code> 中 <code>Some</code> 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 <code>Matched, y = 5</code>。</p>
<p>如果 <code>x</code> 的值是 <code>None</code> 而不是 <code>Some(5)</code>，头两个分支的模式不会匹配，所以会匹配下划线。这个分支的模式中没有引入变量 <code>x</code>，所以此时表达式中的 <code>x</code> 会是外部没有被覆盖的 <code>x</code>。在这个假想的例子中，<code>match</code> 将会打印 <code>Default case, x = None</code>。</p>
<p>一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>为了创建能够比较外部 <code>x</code> 和 <code>y</code> 的值，而不引入覆盖变量的 <code>match</code> 表达式，我们需要相应地使用带有条件的匹配守卫（match guard）。我们稍后将在 <a href="basic/match-pattern/all-patterns.html#extra-conditionals-with-match-guards">“匹配守卫提供的额外条件”</a> 这一小节讨论匹配守卫。</p>
<h3 id="多个模式"><a class="header" href="#多个模式">多个模式</a></h3>
<p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>（<em>or</em>）的意思。例如，如下代码将 <code>x</code> 的值与匹配分支相比较，第一个分支有 <strong>或</strong> 选项，意味着如果 <code>x</code> 的值匹配此分支的任一个值，它就会运行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码会打印 <code>one or two</code>。</p>
<h3 id="通过--匹配值的范围"><a class="header" href="#通过--匹配值的范围">通过 <code>..=</code> 匹配值的范围</a></h3>
<p><code>..=</code> 语法允许你匹配一个闭区间范围内的值。在如下代码中，当模式匹配任何在此范围内的值时，该分支会执行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

match x {
    1..=5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 <code>|</code> 运算符表达相同的意思更为方便；相比 <code>1..=5</code>，使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code>。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！</p>
<p>范围只允许用于数字或 <code>char</code> 值，因为编译器会在编译时检查范围不为空。<code>char</code> 和 数字值是 Rust 仅有的可以判断范围是否为空的类型。</p>
<p>如下是一个使用 <code>char</code> 类型值范围的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 'c';

match x {
    'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 知道 <code>c</code> 位于第一个模式的范围内，并会打印出 <code>early ASCII letter</code>。</p>
<h3 id="解构并分解值"><a class="header" href="#解构并分解值">解构并分解值</a></h3>
<p>也可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。让我们来分别看一看。</p>
<h4 id="解构结构体"><a class="header" href="#解构结构体">解构结构体</a></h4>
<p>示例 18-12 展示带有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>，可以通过带有模式的 <code>let</code> 语句将其分解：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">示例 18-12: 解构一个结构体的字段为单独的变量</span></p>
<p>这段代码创建了变量 <code>a</code> 和 <code>b</code> 来匹配结构体 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段。这个例子展示了模式中的变量名不必与结构体中的字段名一致。不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。</p>
<p>因为变量名匹配字段名是常见的，同时因为 <code>let Point { x: x, y: y } = p;</code> 包含了很多重复，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。示例 18-13 展示了与示例 18-12 有着相同行为的代码，不过 <code>let</code> 模式创建的变量为 <code>x</code> 和 <code>y</code> 而不是 <code>a</code> 和 <code>b</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">示例 18-13: 使用结构体字段简写来解构结构体字段</span></p>
<p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，与变量 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p>
<p>也可以使用字面值作为结构体模式的一部分进行进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。</p>
<p>示例 18-14 展示了一个 <code>match</code> 语句将 <code>Point</code> 值分成了三种情况：直接位于 <code>x</code> 轴上（此时 <code>y = 0</code> 为真）、位于 <code>y</code> 轴上（<code>x = 0</code>）或不在任何轴上的点。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-14: 解构和匹配模式中的字面值</span></p>
<p>第一个分支通过指定字段 <code>y</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>x</code> 轴上的点。此模式仍然创建了变量 <code>x</code> 以便在分支的代码中使用。</p>
<p>类似的，第二个分支通过指定字段 <code>x</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>y</code> 轴上的点，并为字段 <code>y</code> 创建了变量 <code>y</code>。第三个分支没有指定任何字面值，所以其会匹配任何其他的 <code>Point</code> 并为 <code>x</code> 和 <code>y</code> 两个字段创建变量。</p>
<p>在这个例子中，值 <code>p</code> 因为其 <code>x</code> 包含 0 而匹配第二个分支，因此会打印出 <code>On the y axis at 7</code>。</p>
<h4 id="解构枚举"><a class="header" href="#解构枚举">解构枚举</a></h4>
<p>本书之前的部分曾经解构过枚举，比如第六章中示例 6-5 中解构了一个 <code>Option&lt;i32&gt;</code>。一个当时没有明确提到的细节是解构枚举的模式需要对应枚举所定义的储存数据的方式。让我们以示例 6-2 中的 <code>Message</code> 枚举为例，编写一个 <code>match</code> 使用模式解构每一个内部值，如示例 18-15 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-15: 解构包含不同类型值成员的枚举</span></p>
<p>这段代码会打印出 <code>Change the color to red 0, green 160, and blue 255</code>。尝试改变 <code>msg</code> 的值来观察其他分支代码的运行。</p>
<p>对于像 <code>Message::Quit</code> 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 <code>Message::Quit</code>，因此模式中没有任何变量。</p>
<p>对于像 <code>Message::Move</code> 这样的类结构体枚举成员，可以采用类似于匹配结构体的模式。在成员名称后，使用大括号并列出字段变量以便将其分解以供此分支的代码使用。这里使用了示例 18-13 所展示的简写。</p>
<p>对于像 <code>Message::Write</code> 这样的包含一个元素，以及像 <code>Message::ChangeColor</code> 这样包含三个元素的类元组枚举成员，其模式则类似于用于解构元组的模式。模式中变量的数量必须与成员中元素的数量一致。</p>
<h4 id="解构嵌套的结构体和枚举"><a class="header" href="#解构嵌套的结构体和枚举">解构嵌套的结构体和枚举</a></h4>
<p>目前为止，所有的例子都只匹配了深度为一级的结构体或枚举。当然也可以匹配嵌套的项！</p>
<p>例如，我们可以重构列表 18-15 的代码来同时支持 RGB 和 HSV 色彩模式：</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(
                &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
                h,
                s,
                v
            )
        }
        _ =&gt; ()
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-16: 匹配嵌套的枚举</span></p>
<p><code>match</code> 表达式第一个分支的模式匹配一个包含 <code>Color::Rgb</code> 枚举成员的 <code>Message::ChangeColor</code> 枚举成员，然后模式绑定了 3 个内部的 <code>i32</code> 值。第二个分支的模式也匹配一个 <code>Message::ChangeColor</code> 枚举成员， 但是其内部的枚举会匹配 <code>Color::Hsv</code> 枚举成员。我们可以在一个 <code>match</code> 表达式中指定这些复杂条件，即使会涉及到两个枚举。</p>
<h4 id="解构结构体和元组"><a class="header" href="#解构结构体和元组">解构结构体和元组</a></h4>
<p>甚至可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>这将复杂的类型分解成部分组件以便可以单独使用我们感兴趣的值。</p>
<p>通过模式解构是一个方便利用部分值片段的手段，比如结构体中每个单独字段的值。</p>
<h3 id="忽略模式中的值"><a class="header" href="#忽略模式中的值">忽略模式中的值</a></h3>
<p>有时忽略模式中的一些值是有用的，比如 <code>match</code> 中最后捕获全部情况的分支实际上没有做任何事，但是它确实对所有剩余情况负责。有一些简单的方法可以忽略模式中全部或部分值：使用 <code>_</code> 模式（我们已经见过了），在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。让我们来分别探索如何以及为什么要这么做。</p>
<h4 id="使用-_-忽略整个值"><a class="header" href="#使用-_-忽略整个值">使用 <code>_</code> 忽略整个值</a></h4>
<p>我们已经使用过下划线（<code>_</code>）作为匹配但不绑定任何值的通配符模式了。虽然 <code>_</code> 模式作为 <code>match</code> 表达式最后的分支特别有用，也可以将其用于任意模式，包括函数参数中，如示例 18-17 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">示例 18-17: 在函数签名中使用 <code>_</code></span></p>
<p>这段代码会完全忽略作为第一个参数传递的值 <code>3</code>，并会打印出 <code>This code only uses the y parameter: 4</code>。</p>
<p>大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。在一些情况下忽略函数参数会变得特别有用，比如实现 trait 时，当你需要特定类型签名但是函数实现并不需要某个参数时。此时编译器就不会警告说存在未使用的函数参数，就跟使用命名参数一样。</p>
<h4 id="使用嵌套的-_-忽略部分值"><a class="header" href="#使用嵌套的-_-忽略部分值">使用嵌套的 <code>_</code> 忽略部分值</a></h4>
<p>也可以在一个模式内部使用<code>_</code> 忽略部分值，例如，当只需要测试部分值但在期望运行的代码中没有用到其他部分时。示例 18-18 展示了负责管理设置值的代码。业务需求是用户不允许覆盖现有的自定义设置，但是可以取消设置，也可以在当前未设置时为其提供设置。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-18: 当不需要 <code>Some</code> 中的值时在模式内使用下划线来匹配 <code>Some</code> 成员</span></p>
<p>这段代码会打印出 <code>Can't overwrite an existing customized value</code> 接着是 <code>setting is Some(5)</code>。在第一个匹配分支，我们不需要匹配或使用任一个 <code>Some</code> 成员中的值；重要的部分是需要测试 <code>setting_value</code> 和 <code>new_setting_value</code> 都为 <code>Some</code> 成员的情况。在这种情况，我们打印出为何不改变 <code>setting_value</code>，并且不会改变它。</p>
<p>对于所有其他情况（<code>setting_value</code> 或 <code>new_setting_value</code> 任一为 <code>None</code>），这由第二个分支的 <code>_</code> 模式体现，这时确实希望允许 <code>new_setting_value</code> 变为 <code>setting_value</code>。</p>
<p>也可以在一个模式中的多处使用下划线来忽略特定值，如示例 18-19 所示，这里忽略了一个五元元组中的第二和第四个值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-19: 忽略元组的多个部分</span></p>
<p>这会打印出 <code>Some numbers: 2, 8, 32</code>, 值 4 和 16 会被忽略。</p>
<h4 id="通过在名字前以一个下划线开头来忽略未使用的变量"><a class="header" href="#通过在名字前以一个下划线开头来忽略未使用的变量">通过在名字前以一个下划线开头来忽略未使用的变量</a></h4>
<p>如果你创建了一个变量却不在任何地方使用它, Rust 通常会给你一个警告，因为这可能会是个 bug。但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。示例 18-20 中创建了两个未使用变量，不过当运行代码时只会得到其中一个的警告：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">示例 18-20: 以下划线开始变量名以便去掉未使用变量警告</span></p>
<p>这里得到了警告说未使用变量 <code>y</code>，不过没有警告说未使用下划线开头的变量。</p>
<p>注意, 只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。为了展示这个区别的意义，示例 18-21 会产生一个错误。</p>
<pre><code class="language-rust ignore does_not_compile">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">示例 18-21: 以下划线开头的未使用变量仍然会绑定值，它可能会获取值的所有权</span></p>
<p>我们会得到一个错误，因为 <code>s</code> 的值仍然会移动进 <code>_s</code>，并阻止我们再次使用 <code>s</code>。然而只使用下划线本身，并不会绑定值。示例 18-22 能够无错编译，因为 <code>s</code> 没有被移动进 <code>_</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-22: 单独使用下划线不会绑定值</span></p>
<p>上面的代码能很好的运行；因为没有把 <code>s</code> 绑定到任何变量；它没有被移动。</p>
<h4 id="用--忽略剩余值"><a class="header" href="#用--忽略剩余值">用 <code>..</code> 忽略剩余值</a></h4>
<p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分并忽略其它值，同时避免不得不每一个忽略值列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分。在示例 18-23 中，有一个 <code>Point</code> 结构体存放了三维空间中的坐标。在 <code>match</code> 表达式中，我们希望只操作 <code>x</code> 坐标并忽略 <code>y</code> 和 <code>z</code> 字段的值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-23: 通过使用 <code>..</code> 来忽略 <code>Point</code> 中除 <code>x</code> 以外的字段</span></p>
<p>这里列出了 <code>x</code> 值，接着仅仅包含了 <code>..</code> 模式。这比不得不列出 <code>y: _</code> 和 <code>z: _</code> 要来得简单，特别是在处理有很多字段的结构体，但只涉及一到两个字段时的情形。</p>
<p><code>..</code> 会扩展为所需要的值的数量。示例 18-24 展示了元组中 <code>..</code> 的应用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-24: 只匹配元组中的第一个和最后一个值并忽略掉所有其它值</span></p>
<p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p>
<p>然而使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。示例 18-25 展示了一个带有歧义的 <code>..</code> 例子，因此其不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">示例 18-25: 尝试以有歧义的方式运用 <code>..</code></span></p>
<p>如果编译上面的例子，会得到下面的错误：</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>Rust 不可能决定在元组中匹配 <code>second</code> 值之前应该忽略多少个值，以及在之后忽略多少个值。这段代码可能表明我们意在忽略 <code>2</code>，绑定 <code>second</code> 为 <code>4</code>，接着忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；抑或是意在忽略 <code>2</code> 和 <code>4</code>，绑定 <code>second</code> 为 <code>8</code>，接着忽略 <code>16</code> 和 <code>32</code>，以此类推。变量名 <code>second</code> 对于 Rust 来说并没有任何特殊意义，所以会得到编译错误，因为在这两个地方使用 <code>..</code> 是有歧义的。</p>
<h3 id="匹配守卫提供的额外条件"><a class="header" href="#匹配守卫提供的额外条件">匹配守卫提供的额外条件</a></h3>
<p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。</p>
<p>这个条件可以使用模式中创建的变量。示例 18-26 展示了一个 <code>match</code>，其中第一个分支有模式 <code>Some(x)</code> 还有匹配守卫 <code>if x &lt; 5</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-26: 在模式中加入匹配守卫</span></p>
<p>上例会打印出 <code>less than five: 4</code>。当 <code>num</code> 与模式中第一个分支比较时，因为 <code>Some(4)</code> 匹配 <code>Some(x)</code> 所以可以匹配。接着匹配守卫检查 <code>x</code> 值是否小于 <code>5</code>，因为 <code>4</code> 小于 <code>5</code>，所以第一个分支被选择。</p>
<p>相反如果 <code>num</code> 为 <code>Some(10)</code>，因为 10 不小于 5 所以第一个分支的匹配守卫为假。接着 Rust 会前往第二个分支，这会匹配因为它没有匹配守卫所以会匹配任何 <code>Some</code> 成员。</p>
<p>无法在模式中表达 <code>if x &lt; 5</code> 的条件，所以匹配守卫提供了表现此逻辑的能力。</p>
<p>在示例 18-11 中，我们提到可以使用匹配守卫来解决模式中变量覆盖的问题，那里 <code>match</code> 表达式的模式中新建了一个变量而不是使用 <code>match</code> 之外的同名变量。新变量意味着不能够测试外部变量的值。示例 18-27 展示了如何使用匹配守卫修复这个问题。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">示例 18-27: 使用匹配守卫来测试与外部变量的相等性</span></p>
<p>现在这会打印出 <code>Default case, x = Some(5)</code>。现在第二个匹配分支中的模式不会引入一个覆盖外部 <code>y</code> 的新变量 <code>y</code>，这意味着可以在匹配守卫中使用外部的 <code>y</code>。相比指定会覆盖外部 <code>y</code> 的模式 <code>Some(y)</code>，这里指定为 <code>Some(n)</code>。此新建的变量 <code>n</code> 并没有覆盖任何值，因为 <code>match</code> 外部没有变量 <code>n</code>。</p>
<p>匹配守卫 <code>if n == y</code> 并不是一个模式所以没有引入新变量。这个 <code>y</code> <strong>正是</strong> 外部的 <code>y</code> 而不是新的覆盖变量 <code>y</code>，这样就可以通过比较 <code>n</code> 和 <code>y</code> 来表达寻找一个与外部 <code>y</code> 相同的值的概念了。</p>
<p>也可以在匹配守卫中使用 <strong>或</strong> 运算符 <code>|</code> 来指定多个模式，同时匹配守卫的条件会作用于所有的模式。示例 18-28 展示了结合匹配守卫与使用了 <code>|</code> 的模式的优先级。这个例子中重要的部分是匹配守卫 <code>if y</code> 作用于 <code>4</code>、<code>5</code> <strong>和</strong> <code>6</code>，即使这看起来好像 <code>if y</code> 只作用于 <code>6</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-28: 结合多个模式与匹配守卫</span></p>
<p>这个匹配条件表明此分支值匹配 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。运行这段代码时会发生的是第一个分支的模式因 <code>x</code> 为 <code>4</code> 而匹配，不过匹配守卫 <code>if y</code> 为假，所以第一个分支不会被选择。代码移动到第二个分支，这会匹配，此程序会打印出 <code>no</code>。这是因为 <code>if</code> 条件作用于整个 <code>4 | 5 | 6</code> 模式，而不仅是最后的值 <code>6</code>。换句话说，匹配守卫与模式的优先级关系看起来像这样：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>可以通过运行代码时的情况看出这一点：如果匹配守卫只作用于由 <code>|</code> 运算符指定的值列表的最后一个值，这个分支就会匹配且程序会打印出 <code>yes</code>。</p>
<h3 id="-绑定"><a class="header" href="#-绑定"><code>@</code> 绑定</a></h3>
<p><em>at</em> 运算符（<code>@</code>）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。示例 18-29 展示了一个例子，这里我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支相关联的代码可以使用它。可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10..=12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">示例 18-29: 使用 <code>@</code> 在模式中绑定值的同时测试它</span></p>
<p>上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时测试其值匹配这个范围模式。</p>
<p>第二个分支只在模式中指定了一个范围，分支相关代码代码没有一个包含 <code>id</code> 字段实际值的变量。<code>id</code> 字段的值可以是 10、11 或 12，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p>
<p>最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>，因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 <code>id</code> 字段的值进行测试：任何值都会匹配此分支。</p>
<p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值。</p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>模式是 Rust 中一个很有用的功能，它帮助我们区分不同类型的数据。当用于 <code>match</code> 语句时，Rust 确保模式会包含每一个可能的值，否则程序将不能编译。<code>let</code> 语句和函数参数的模式使得这些结构更强大，可以在将值解构为更小部分的同时为变量赋值。可以创建简单或复杂的模式来满足我们的要求。</p>
<p>接下来，在本书倒数第二章中，我们将介绍一些 Rust 众多功能中较为高级的部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-methodmd"><a class="header" href="#function-methodmd">function-method.md</a></h1>
<h2 id="函数返回-1"><a class="header" href="#函数返回-1">函数返回</a></h2>
<p>SPECIAL RETURN TYPES IN RUST</p>
<p>If you are new to the language, some return types are difficult to interpret. These are also especially difficult to search for because they are made from symbols rather than words.</p>
<p>Known as the unit type, () formally is a zero-length tuple. It is used to express that a function returns no value. Functions that appear to have no return type return (), and expressions that are terminated with a semicolon (;) return (). For example, the report() function in the following code block returns the unit type implicitly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
 
fn report&lt;T: Debug&gt;(item: T) {
  println!(&quot;{:?}&quot;, item);
 
}
<span class="boring">}
</span></code></pre></pre>
<p>And this example returns the unit type explicitly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn clear(text: &amp;mut String) -&gt; () {
  *text = String::from(&quot;&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>The unit type often occurs in error messages. It’s common to forget that the last expression of a function shouldn’t end with a semicolon.</p>
<p>The exclamation symbol, !, is known as the “Never” type. Never indicates that a function never returns, especially when it is guaranteed to crash. For example, take this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dead_end() -&gt; ! {
  panic!(&quot;you have reached a dead end&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>The following example creates an infinite loop that prevents the function from returning:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn forever() -&gt; ! {
  loop {
    //...
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>As with the unit type, Never sometimes occurs within error messages. The Rust compiler complains about mismatched types when you forget to add a break in your loop block if you’ve indicated that the function returns a non-Never type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generiticmd"><a class="header" href="#generiticmd">generitic.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traitmd"><a class="header" href="#traitmd">trait.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h1>
<p>In some cases, using the as keyword is too restrictive. It’s possible to regain fuller control over the type conversion process at the cost of introducing some bureaucracy. The following listing shows a Rust method to use instead of the as keyword when the conversion might fail.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;
 
 fn main() {
   let a: i32 = 10;
   let b: u16 = 100;
 
   let b_ = b.try_into()
             .unwrap();
 
   if a &lt; b_ {
     println!(&quot;Ten is less than one hundred.&quot;);
   }
 }
</code></pre></pre>
<p>Listing 2.5 introduces two new Rust concepts: traits and error handling. On line 1, the use keyword brings the std::convert::TryInto trait into local scope. This unlocks the try_into() method of the b variable. We’ll bypass a full explanation of why this occurs for now. In the meantime, consider a trait as a collection of methods. If you are from an object-oriented background, traits can be thought of as abstract classes or interfaces. If your programming experience is in functional languages, you can think of traits as type classes.</p>
<p>Line 7 provides a glimpse of error handling in Rust. b.try_into() returns an i32 value wrapped within a Result. Result is introduced properly in chapter 3. It can contain either a success value or an error value. The unwrap() method can handle the success value and returns the value of b as an i32 here. If the conversion between u16 and i32 were to fail, then calling unsafe() would crash the program. As the book progresses, you will learn safer ways of dealing with Result rather than risking the program’s stability!</p>
<p>A distinguishing characteristic of Rust is that it only allows a type’s methods to be called when the trait is within local scope. An implicit prelude enables common operations such as addition and assignment to be used without explicit imports.</p>
<blockquote>
<p>TIP</p>
<p>To understand what is included in local scope by default, you should investigate the std::prelude module. Its &gt;documentation is available online at https://doc.rust-lang.org/std/prelude/index.html.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-errormd"><a class="header" href="#exception-errormd">exception-error.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advance-rust"><a class="header" href="#advance-rust">advance rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collectionmd"><a class="header" href="#collectionmd">collection.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatted-outputmd"><a class="header" href="#formatted-outputmd">formatted-output.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commentmd"><a class="header" href="#commentmd">comment.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-modulemd"><a class="header" href="#crate-modulemd">crate-module.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期todo"><a class="header" href="#生命周期todo">生命周期(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interatormd"><a class="header" href="#interatormd">interator.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programingmd"><a class="header" href="#functional-programingmd">functional-programing.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointermd"><a class="header" href="#smart-pointermd">smart-pointer.md</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局变量"><a class="header" href="#全局变量">全局变量</a></h1>
<p>在一些场景，我们可能需要全局变量来简化状态共享的代码，包括全局ID，全局数据存储等等，下面我们来一一给出对应的实现方法。</p>
<h2 id="全局唯一id"><a class="header" href="#全局唯一id">全局唯一ID</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{Ordering, AtomicUsize};

struct Factory{
    factory_id: usize,
}

static GLOBAL_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
// This gives large room for ids to overflow
// This code assumes that your app never would need many factories
const MAX_ID: usize = usize::MAX / 2;

fn generate_id()-&gt;usize{
    // Check overflow twice to avoid growing of GLOBAL_ID_COUNTER after overflow.
    let current_val = GLOBAL_ID_COUNTER.load(Ordering::Relaxed);
    if current_val &gt; MAX_ID{
        panic!(&quot;Factory ids overflowed&quot;);
    }
    let next_id = GLOBAL_ID_COUNTER.fetch_add(1, Ordering::Relaxed);
    if next_id &gt; MAX_ID{
        panic!(&quot;Factory ids overflowed&quot;);
    }
    next_id
}

impl Factory{
    fn new()-&gt;Self{
        Self{
            factory_id: generate_id()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic!</a></h1>
<h2 id="panic背后的原理"><a class="header" href="#panic背后的原理">panic背后的原理</a></h2>
<p>Not sure exactly what you're asking, but I'll try to describe the panic mechanism as I understand it. I'm sure folks will correct my mistakes.
When you call the panic!() macro it formats the panic message and then calls std::panic::panic_any() with the message as the argument. panic_any() first checks to see if there's a &quot;panic hook&quot; installed by the application: if so, the hook function is called. Assuming that the hook function returns, the unwinding of the current thread begins with the parent stack frame of the caller of panic_any(). If the registers or the stack are messed up, likely trying to start unwinding will cause an exception of some kind, at which point the thread will be aborted instead of unwinding.
Unwinding is a process of walking back up the stack, frame-by-frame. At each frame, any data owned by the frame is dropped. (I believe things are dropped in reverse static order, as they would be at the end of a function.)
One exceptional case during unwinding is that the unwinding may hit a frame marked as &quot;catching&quot; the unwind via std::panic::catch_unwind(). If so, the supplied catch function is called and unwinding ceases: the catching frame may continue the unwinding with std::panic::resume_unwind() or not.
Another exceptional case during unwinding is that some drop may itself panic. In this case the unwinding thread is aborted.
Once unwinding of a thread is aborted or completed (no more frames to unwind), the outcome depends on which thread panicked. For the main thread, the operating environment's abort functionality is invoked to terminate the panicking process via core::intrinsics::abort(). Child threads, on the other hand, are simply terminated and can be collected later with std::thread::join()</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="适用result返回错误"><a class="header" href="#适用result返回错误">适用Result返回错误</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义错误"><a class="header" href="#自定义错误">自定义错误</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="让错误展示更优雅"><a class="header" href="#让错误展示更优雅">让错误展示更优雅</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="会导致panic的代码"><a class="header" href="#会导致panic的代码">会导致panic的代码</a></h1>
<p>String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the “Storing UTF-8 Encoded Text with Strings” section of Chapter 8.</p>
<blockquote>
<p>比方说有一个 <code>u8</code> ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生<strong>整型溢出</strong>。关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 会检查整型溢出若存在这些问题则使程序在编译时 <em>panic</em>。Rust 使用这个术语来表明程序因错误而退出。 <a href="errors/../../errors/panic.html">该章节</a>会详细介绍 panic。</p>
<p>在当使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。相反当检测到整型溢出时，Rust 会进行一种被称为二进制补码的方式进行（<em>two’s complement wrapping</em>）操作。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖整型溢出包裹的行为不是一种正确的做法。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">cargo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargotoml和cargolock"><a class="header" href="#cargotoml和cargolock">Cargo.toml和Cargo.lock</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h1>
<h2 id="依赖升级"><a class="header" href="#依赖升级">依赖升级</a></h2>
<p>Minor note about your second point: You can use cargo update to update versions of transitive dependencies in your Cargo.lock when applicable; the very nice cargo-edit crate provides a cargo upgrade command which does the same for your Cargo.toml. If you use VSCode, I can also recommend the &quot;crates&quot; extension which shows available updates inline in your Cargo.toml.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建缓存"><a class="header" href="#构建缓存">构建缓存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作空间"><a class="header" href="#工作空间">工作空间</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件编译条件依赖"><a class="header" href="#条件编译条件依赖">条件编译、条件依赖</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">manifest</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义构建脚本"><a class="header" href="#自定义构建脚本">自定义构建脚本</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-profile"><a class="header" href="#cargo-profile">Cargo profile</a></h1>
<h2 id="custom-profiles-rust-1570"><a class="header" href="#custom-profiles-rust-1570">custom profiles (rust 1.57.0)</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志和监控"><a class="header" href="#日志和监控">日志和监控</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志"><a class="header" href="#日志">日志</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   if cfg!(debug_assertions) {
       eprintln!(&quot;debug: {:?} -&gt; {:?}&quot;,
              record, fields);
     }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可观测性"><a class="header" href="#可观测性">可观测性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="监控apm"><a class="header" href="#监控apm">监控(APM)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>部分内容借鉴了Rust book</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box对象todo"><a class="header" href="#box对象todo">Box对象(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref和drop特征todo"><a class="header" href="#deref和drop特征todo">Deref和Drop特征(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc与refcelltodo"><a class="header" href="#rc与refcelltodo">Rc与RefCell(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自引用与内存泄漏"><a class="header" href="#自引用与内存泄漏">自引用与内存泄漏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见特征解析"><a class="header" href="#常见特征解析">常见特征解析</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换frominto"><a class="header" href="#类型转换frominto">类型转换From/Into</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asref-asmut"><a class="header" href="#asref-asmut">AsRef, AsMut</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrow-borrowmut-toowned"><a class="header" href="#borrow-borrowmut-toowned">Borrow, BorrowMut, ToOwned</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref和引用隐式转换"><a class="header" href="#deref和引用隐式转换">Deref和引用隐式转换</a></h1>
<p><code>Deref</code> 是解引用操作符<code>*</code>的特征，比如 *v。</p>
<p>一般理解，<code>*v</code>操作，是<code>&amp;v</code>的反向操作，是为了获取<code>&amp;v</code>指针指向的堆上对象。</p>
<h2 id="强制隐式转换"><a class="header" href="#强制隐式转换">强制隐式转换</a></h2>
<p>Deref最神奇、最好用的地方并不在本身<code>解引</code>这个意义上，Rust的设计者在它之上附加了一个特性：强制隐式转换，这才是它神奇之处。</p>
<p>这种隐式转换的规则为：</p>
<p>一个类型为<code>T</code>的对象<code>foo</code>，如果T: Deref&lt;Target=U&gt;，那么，相关<code>foo</code>的引用<code>&amp;foo</code>在应用的时候会自动转换<code>&amp;U</code>。</p>
<p>粗看这条规则，貌似有点类似于<code>AsRef</code>，而跟<code>解引</code>似乎风马牛不相及, 实际里面里面有些玄妙之处。</p>
<p>Rust编译器会在做<code>*v</code>操作的时候，自动先把<code>v</code>做引用归一化操作，即转换成内部通用引用的形式<code>&amp;v</code>，整个表达式就变成 <code>*&amp;v</code>。这里面有两种情况：</p>
<ol>
<li>把智能指针（比如在库中定义的，Box, Rc, Arc, Cow 等），去掉壳，转成内部标准形式<code>&amp;v</code>；</li>
<li>把多重<code>&amp;</code> （比如：<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>），简化成<code>&amp;v</code>（通过插入足够数量的<code>*</code>进行解引）。
所以，它实际上在解引用之前做了一个引用的归一化操作。</li>
</ol>
<p>为什么要转呢？ 因为编译器设计的能力是，只能够对 &amp;v 这种引用进行解引用。其它形式的它不认识，所以要做引用归一化操作。</p>
<p>使用引用进行过渡也是为了能够防止不必要的拷贝。</p>
<p>下面举一些例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn foo(s: &amp;str) {
        // borrow a string for a second
    }

    // String implements Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();

    // therefore, this works:
    foo(&amp;owned);
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>String</code>实现了<code>Deref&lt;Target=str&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::rc::Rc;

    fn foo(s: &amp;str) {
        // borrow a string for a second
    }

    // String implements Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();
    let counted = Rc::new(owned);

    // therefore, this works:
    foo(&amp;counted);
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>Rc&lt;T&gt;</code>实现了<code>Deref&lt;Target=T&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn foo(s: &amp;[i32]) {
        // borrow a slice for a second
    }

    // Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;
    let owned = vec![1, 2, 3];

    foo(&amp;owned);
<span class="boring">}
</span></code></pre></pre>
<p>因为<code>Vec&lt;T&gt;</code> 实现了<code>Deref&lt;Target=[T]&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Foo;

    impl Foo {
        fn foo(&amp;self) { println!(&quot;Foo&quot;); }
    }

    let f = &amp;&amp;Foo;

    f.foo();
    (&amp;f).foo();
    (&amp;&amp;f).foo();
    (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
<span class="boring">}
</span></code></pre></pre>
<p>上面那几种函数的调用，效果是一样的。</p>
<p>这种<code>Deref</code>涉及的隐式转换，实际上是Rust中仅有的类型隐式转换，设计它的目的，是为了简化程序的书写，让代码不至于过于繁琐。把人从无尽的类型细节中解脱出来，让书写 Rust 代码变成一件快乐的事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="写时拷贝cow"><a class="header" href="#写时拷贝cow">写时拷贝Cow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程"><a class="header" href="#多线程">多线程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程管理todo"><a class="header" href="#线程管理todo">线程管理(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="消息传递todo"><a class="header" href="#消息传递todo">消息传递(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rcarcmutexrwlocktodo"><a class="header" href="#rcarcmutexrwlocktodo">Rc、Arc、Mutex、Rwlock(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据竞争"><a class="header" href="#数据竞争">数据竞争</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sendsynctodo"><a class="header" href="#sendsynctodo">Send、Sync(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入内存"><a class="header" href="#深入内存">深入内存</a></h1>
<p>部分内容借鉴了Rust in action和Rust高级编程</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指针和引用todo"><a class="header" href="#指针和引用todo">指针和引用(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="未初始化内存"><a class="header" href="#未初始化内存">未初始化内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存分配todo"><a class="header" href="#内存分配todo">内存分配(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存布局todo"><a class="header" href="#内存布局todo">内存布局(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟内存"><a class="header" href="#虚拟内存">虚拟内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络和异步编程"><a class="header" href="#网络和异步编程">网络和异步编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcp和网络原理todo"><a class="header" href="#tcp和网络原理todo">TCP和网络原理(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发与并行todo"><a class="header" href="#并发与并行todo">并发与并行(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h1>
<p>https://rust-lang.github.io/async-book/01_getting_started/03_state_of_async_rust.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait语法"><a class="header" href="#asyncawait语法">async/await语法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future详解"><a class="header" href="#future详解">future详解</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future特征"><a class="header" href="#future特征">Future特征</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="任务调度"><a class="header" href="#任务调度">任务调度</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="任务执行器"><a class="header" href="#任务执行器">任务执行器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统io"><a class="header" href="#系统io">系统IO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="执行多个future"><a class="header" href="#执行多个future">执行多个Future</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pinunpintodo"><a class="header" href="#pinunpintodo">Pin、Unpin(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="遇到不支持的异步特性"><a class="header" href="#遇到不支持的异步特性">遇到不支持的异步特性?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-clientserver"><a class="header" href="#http-clientserver">HTTP Client/Server</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定海神针-tokio包"><a class="header" href="#定海神针-tokio包">定海神针-tokio包</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步消息流"><a class="header" href="#异步消息流">异步消息流</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见陷阱-todo"><a class="header" href="#常见陷阱-todo">常见陷阱 todo</a></h1>
<p>本章收集各种Rust使用中常见的陷阱，帮助大家提前规避或者在遇到时能够迅速解决。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust代码风格"><a class="header" href="#rust代码风格">Rust代码风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h1>
<p>基本的Rust命名规范在<a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a>中有描述.</p>
<p>通常，对于&quot;type-level&quot;的构造Rust倾向于使用驼峰命名,而对于'value-level'的构造使用蛇形命名。详情如下:</p>
<table><thead><tr><th>条目</th><th>惯例</th></tr></thead><tbody>
<tr><td>包Crates</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">unclear</a></td></tr>
<tr><td>模块Modules</td><td><code>snake_case</code></td></tr>
<tr><td>类型Types</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特征Traits</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举项</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数Functions</td><td><code>snake_case</code></td></tr>
<tr><td>方法Methods</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造器General constructors</td><td><code>new</code> or <code>with_more_details</code></td></tr>
<tr><td>转换构造器Conversion constructors</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏Macros</td><td><code>snake_case!</code></td></tr>
<tr><td>局部变量Local variables</td><td><code>snake_case</code></td></tr>
<tr><td>静态类型Statics</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量Constants</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数Type parameters</td><td><code>UpperCamelCase</code>, 通常使用一个大写字母: <code>T</code></td></tr>
<tr><td>生命周期Lifetimes</td><td>通常使用小写字母: <code>'a</code>, <code>'de</code>, <code>'src</code></td></tr>
<tr><td>Features</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101">unclear</a> but see <a href="style-guide/naming.html#c-feature">C-FEATURE</a></td></tr>
</tbody></table>
<p>对于驼峰命名法, 复合词的缩略形式我们认为是一个单独的词语，所以只对首字母进行大写: 使用<code>Uuid</code>而不是<code>UUID</code>, <code>Usize</code>而不是<code>USize</code>, <code>Stdin</code>而不是<code>StdIn</code>.对于蛇形命名法，缩略词用全小写: <code>is_xid_start</code>.</p>
<p>对于蛇形命名(包括全大写的<code>SCREAMING_SNAKE_CASE</code>), 除了最后一部分，其它部分的词语都不能由单个字母组成：
<code>btree_map</code>而不是<code>b_tree_map</code>, <code>PI_2</code>而不是<code>PI2</code>.</p>
<p>包名不应该使用<code>-rs</code>或者<code>-rust</code>作为后缀，因为每一个包都是Rust写的，因此这种多余的注释其实没有任何意义。</p>
<h2 id="类型转换要遵守as_-to_-into_命名惯例c-conv"><a class="header" href="#类型转换要遵守as_-to_-into_命名惯例c-conv">类型转换要遵守<code>as_</code>, <code>to_</code>, <code>into_</code>命名惯例(C-CONV)</a></h2>
<p>类型转换应该通过方法调用的方式实现，其中的前缀规则如下：</p>
<table><thead><tr><th>方法前缀</th><th>性能开销</th><th>所有权改变</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>Free</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>Expensive</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (non-Copy types)<br>owned -&gt; owned (Copy types)</td></tr>
<tr><td><code>into_</code></td><td>Variable</td><td>owned -&gt; owned (non-Copy types)</td></tr>
</tbody></table>
<p>For example:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 把<code>str</code>变成UTF-8字节数组, 性能开销是0. 其中输入是一个借用的<code>&amp;str</code>，输出也是一个借用的<code>&amp;str</code>.</li>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str"><code>Path::to_str</code></a> 会执行一次昂贵的UTF-8字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为<code>as_str</code>是不正确的，因为这个方法的开销还挺大.</li>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase"><code>str::to_lowercase()</code></a>在调用过程中会遍历字符串的字符，且可能会分配新的内存对象.输入是一个借用的<code>str</code>，输出是一个有独立所有权的<code>String</code></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a>返回<code>String</code>底层的<code>Vec&lt;u8&gt;</code>数组，转换本身是零消耗的。该方法获取<code>String</code>的所有权，然后返回一个新的有独立所有权的<code>Vec&lt;u8&gt;</code></li>
</ul>
<p>当一个单独的值被某个类型所包装时，访问该类型的内部值应通过<code>into_inner()</code>方法来访问。例如将一个缓冲区值包装为<a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a>类型，还有<a href="https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>、<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a>等，都是这种类型。</p>
<p>如果<code>mut</code>限定符在返回类型中出现，那么在命名上也应该体现出来。例如，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 就说明它返回了一个mut切片，在这种情况下<code>as_mut_slice</code>比<code>as_slice_mut</code>更适合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回类型是一个mut切片.
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
<span class="boring">}
</span></code></pre></pre>
<h5 id="标准库中的一些例子"><a class="header" href="#标准库中的一些例子">标准库中的一些例子</a></h5>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<h2 id="读访问器getter的名称遵循rust的命名规范c-getter"><a class="header" href="#读访问器getter的名称遵循rust的命名规范c-getter">读访问器(Getter)的名称遵循Rust的命名规范(C-GETTER)</a></h2>
<p>除了少数例外，在Rust代码中<code>get</code>前缀不用于getter。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 而不是get_first
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 而不是get_first_mut, get_mut_first, or mut_first.
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至于上文提到的少数例外，如下：当有且仅有一个值能被getter所获取时，才使用<code>get</code>前缀。例如，
<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get"><code>Cell::get</code></a>能直接访问到<code>Cell</code>中的内容。</p>
<p>有些getter会在过程中执行运行时检查，那么我们就可以考虑添加<code>_unchecked</code>getter函数，这个函数虽然不安全，但是往往具有更高的性能，
典型的例子如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<h3 id="标准库示例"><a class="header" href="#标准库示例">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<h2 id="一个集合上的方法如果返回迭代器需遵循命名规则iter-iter_mut-into_iter-c-iter"><a class="header" href="#一个集合上的方法如果返回迭代器需遵循命名规则iter-iter_mut-into_iter-c-iter">一个集合上的方法，如果返回迭代器，需遵循命名规则：<code>iter</code>, <code>iter_mut</code>, <code>into_iter</code> (C-ITER)</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter(&amp;self) -&gt; Iter             // Iter implements Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut implements Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter implements Iterator&lt;Item = U&gt;
<span class="boring">}
</span></code></pre></pre>
<p>上面的规则适用于同构性的数据集合。与之相反，<code>str</code>类型是一个utf8字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了<a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes"><code>str::bytes</code></a>去遍历字节，还有<a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a>去遍历字符，而并没有直接定义<code>iter</code>等方法。</p>
<p>上述规则只适用于方法，并不适用于函数。例如<code>url</code>包的<a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a>函数返回一个迭代器用于遍历百分比编码(<a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent encoding</a>)的字符串片段. 在这种情况下，使用<code>iter</code>/<code>iter_mut</code>/<code>into_iter</code>诸如此类的函数命名无法表达任何具体的含义。</p>
<h3 id="标准库示例-1"><a class="header" href="#标准库示例-1">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
</ul>
<h2 id="迭代器的类型应该与产生它的方法名相匹配c-iter-ty"><a class="header" href="#迭代器的类型应该与产生它的方法名相匹配c-iter-ty">迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)</a></h2>
<p>例如形如<code>into_iter()</code>的方法应该返回一个<code>IntoIter</code>类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。</p>
<p>上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的url包中的<a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a>函数，返回了一个[<code>PercentEncode</code>]类型.</p>
<p>特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如<a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>vec::IntoIter</code></a>.</p>
<h3 id="标准库示例-2"><a class="header" href="#标准库示例-2">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>Iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html"><code>IterMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a> returns <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>IntoIter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html"><code>Keys</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html"><code>Values</code></a></li>
</ul>
<p><a id="c-feature"></a></p>
<h2 id="cargo-feature的名称不应该包含占位词c-feature"><a class="header" href="#cargo-feature的名称不应该包含占位词c-feature">Cargo Feature的名称不应该包含占位词(C-FEATURE)</a></h2>
<p>不要在<a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a>中包含无法传达任何意义的词，例如<code>use-abc</code>或<code>with-abc</code>，直接命名为<code>abc</code>即可。</p>
<p>一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：</p>
<pre><code class="language-toml"># 在Cargo.toml中

[features]
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在我们自定义的lib.rs中

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
<span class="boring">}
</span></code></pre></pre>
<p>除了<code>std</code>之外，不要使用任何<code>ust-std</code>或者<code>with-std</code>等自以为很有创造性的名称。</p>
<h2 id="命名要使用一致性的词序c-word-order"><a class="header" href="#命名要使用一致性的词序c-word-order">命名要使用一致性的词序(C-WORD-ORDER)</a></h2>
<p>这是一些标准库中的错误类型:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>它们都使用了<code>谓语-宾语-错误</code>的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下<code>ParseAddrError</code>,而不是<code>AddrParseError</code>。</p>
<p>词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码风格todo"><a class="header" href="#代码风格todo">代码风格(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码标记"><a class="header" href="#代码标记">代码标记</a></h1>
<p>unimplemented!() todo!()</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oo所需的特性"><a class="header" href="#oo所需的特性">OO所需的特性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特征对象"><a class="header" href="#特征对象">特征对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe"><a class="header" href="#unsafe">unsafe</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-pointer"><a class="header" href="#raw-pointer">raw pointer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="修改全局变量"><a class="header" href="#修改全局变量">修改全局变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi外部语言用"><a class="header" href="#ffi外部语言用">FFI外部语言用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对抗编译检查"><a class="header" href="#对抗编译检查">对抗编译检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幽灵数据"><a class="header" href="#幽灵数据">幽灵数据</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期todo-1"><a class="header" href="#生命周期todo-1">生命周期(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型未限制"><a class="header" href="#类型未限制">类型未限制</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">performance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone和copy"><a class="header" href="#clone和copy">Clone和Copy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">benchmark</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="减少runtime-check"><a class="header" href="#减少runtime-check">减少runtime check</a></h1>
<h2 id="减少集合访问的边界检查"><a class="header" href="#减少集合访问的边界检查">减少集合访问的边界检查</a></h2>
<p>以下代码，我们实现了两种循环方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
<span class="boring">}
</span></code></pre></pre>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环迭代集合中的元素，优劣如下：</p>
<ul>
<li><strong>性能</strong>：第一种使用方式中<code>collection[index]</code>的索引访问，会因为边界检查(bounds checking)导致运行时的性能损耗 - Rust会检查并确认<code>index</code>是落在集合内也就是合法的，但是第二种直接迭代的方式就不会触发这种检查,因为编译器会在编译时就完成分析并证明这种访问是合法的`</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对抗编译检查-1"><a class="header" href="#对抗编译检查-1">对抗编译检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见属性标记"><a class="header" href="#常见属性标记">常见属性标记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准库解析"><a class="header" href="#标准库解析">标准库解析</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="寻找你想要的内容"><a class="header" href="#寻找你想要的内容">寻找你想要的内容</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用三方库"><a class="header" href="#常用三方库">常用三方库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">Json</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serdetodo"><a class="header" href="#serdetodo">serde(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http"><a class="header" href="#http">Http</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reqwesttodo"><a class="header" href="#reqwesttodo">reqwest(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行解析"><a class="header" href="#命令行解析">命令行解析</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structopttodo"><a class="header" href="#structopttodo">structopt(todo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="场景模版"><a class="header" href="#场景模版">场景模版</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="目录"><a class="header" href="#目录">目录</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http请求"><a class="header" href="#http请求">Http请求</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>附录中包含了一些Rust常用概念的快速索引，方便你的日常查询使用。</p>
<blockquote>
<p>大部分的附录借鉴了Rust Book以及相应的<a href="https://rustwiki.org/zh-CN/book/">中文翻译书籍</a>，但同时做了一些的修改，增加准确性和阅读流畅度</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-a关键字"><a class="header" href="#附录-a关键字">附录 A：关键字</a></h2>
<p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了<a href="appendix/keywords.html#%E5%8E%9F%E7%94%9F%E6%A0%87%E8%AF%86%E7%AC%A6">原生标识符</a>），包括函数、变量、参数、结构体字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期。</p>
<h3 id="目前正在使用的关键字"><a class="header" href="#目前正在使用的关键字">目前正在使用的关键字</a></h3>
<p>如下关键字目前有对应其描述的功能。</p>
<ul>
<li><code>as</code> - 强制类型转换，或<code>use</code> 和 <code>extern crate</code>包和模块引入语句中的重命名</li>
<li><code>break</code> - 立刻退出循环</li>
<li><code>const</code> - 定义常量或原生常量指针（constant raw pointer）</li>
<li><code>continue</code> - 继续进入下一次循环迭代</li>
<li><code>crate</code> - 链接外部包</li>
<li><code>dyn</code> - 动态分发特征对象</li>
<li><code>else</code> - 作为 <code>if</code> 和 <code>if let</code> 控制流结构的 fallback</li>
<li><code>enum</code> - 定义一个枚举类型</li>
<li><code>extern</code> - 链接一个外部包,或者一个宏变量(该变量定义在另外一个包中)</li>
<li><code>false</code> - 布尔值 <code>false</code></li>
<li><code>fn</code> - 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li>
<li><code>for</code> - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期</li>
<li><code>if</code> - 基于条件表达式的结果来执行相应的分支</li>
<li><code>impl</code> - 为结构体或者特征实现具体功能</li>
<li><code>in</code> - <code>for</code> 循环语法的一部分</li>
<li><code>let</code> - 绑定一个变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 模式匹配</li>
<li><code>mod</code> - 定义一个模块</li>
<li><code>move</code> - 使闭包获取其所捕获项的所有权</li>
<li><code>mut</code> - 在引用、原生指针或模式绑定中使用，表明变量是可变的</li>
<li><code>pub</code> - 表示结构体字段、<code>impl</code> 块或模块的公共可见性</li>
<li><code>ref</code> - 通过引用绑定</li>
<li><code>return</code> - 从函数中返回</li>
<li><code>Self</code> - 实现特征类型的类型别名</li>
<li><code>self</code> - 表示方法本身或当前模块</li>
<li><code>static</code> - 表示全局变量或在整个程序执行期间保持其生命周期</li>
<li><code>struct</code> - 定义一个结构体</li>
<li><code>super</code> - 表示当前模块的父模块</li>
<li><code>trait</code> - 定义一个特征</li>
<li><code>true</code> - 布尔值 <code>true</code></li>
<li><code>type</code> - 定义一个类型别名或关联类型</li>
<li><code>unsafe</code> - 表示不安全的代码、函数、特征或实现</li>
<li><code>use</code> - 在当前代码范围内(模块或者花括号对)引入外部的包、模块等</li>
<li><code>where</code> - 表示一个约束类型的从句</li>
<li><code>while</code> - 基于一个表达式的结果判断是否继续循环</li>
</ul>
<h3 id="保留做将来使用的关键字"><a class="header" href="#保留做将来使用的关键字">保留做将来使用的关键字</a></h3>
<p>如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="原生标识符"><a class="header" href="#原生标识符">原生标识符</a></h3>
<p>原生标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 <code>r#</code> 前缀。</p>
<p>例如，<code>match</code> 是关键字。如果尝试编译如下使用 <code>match</code> 作为名字的函数：</p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>会得到这个错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>该错误表示你不能将关键字 <code>match</code> 用作函数标识符。你可以使用原生标识符将 <code>match</code> 作为函数名称使用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>此代码编译没有任何错误。注意 <code>r#</code> 前缀需同时用于函数名定义和 <code>main</code> 函数中的调用。</p>
<p>原生标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。 此外，原生标识符允许你使用其它Rust版本编写的库。比如，<code>try</code> 在Rust 2015 edition 中不是关键字，却在Rust 2018 edition是关键字。所以如果用2015 edition 编写的库中带有 <code>try</code> 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 <code>r#try</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-b运算符与符号"><a class="header" href="#附录-b运算符与符号">附录 B：运算符与符号</a></h2>
<p>该附录包含了 Rust 目前出现过的各种符号，这些符号之前都分散在各个章节中。</p>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<p>表 B-1 包含了 Rust 中的运算符、上下文中的示例、简短解释以及该运算符是否可重载。如果一个运算符是可重载的，则该运算符上用于重载的特征也会列出。</p>
<p>下表中，<code>expr</code>是表达式，<code>ident</code>是标识符,<code>type</code>是类型,<code>var</code>是变量，<code>trait</code>是特征,<code>pat</code>是匹配分支(pattern)。</p>
<p><span class="caption">表 B-1: 运算符</span>
| 运算符 | 示例 | 解释 | 是否可重载 |
|----------|---------|-------------|---------------|
| <code>!</code> | <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code> | 宏展开 |  |
| <code>!</code> | <code>!expr</code> | 按位非或逻辑非 | <code>Not</code> |
| <code>!=</code> | <code>var != expr</code> | 不等比较 | <code>PartialEq</code> |
| <code>%</code> | <code>expr % expr</code> | 算术求余 | <code>Rem</code> |
| <code>%=</code> | <code>var %= expr</code> | 算术求余与赋值 | <code>RemAssign</code> |
| <code>&amp;</code> | <code>&amp;expr</code>, <code>&amp;mut expr</code> | 借用 | |
| <code>&amp;</code> | <code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code> | 借用指针类型 |  |
| <code>&amp;</code> | <code>expr &amp; expr</code> | 按位与 | <code>BitAnd</code> |
| <code>&amp;=</code> | <code>var &amp;= expr</code> | 按位与及赋值 | <code>BitAndAssign</code> |
| <code>&amp;&amp;</code> | <code>expr &amp;&amp; expr</code> | 逻辑与 |  |
| <code>*</code> | <code>expr * expr</code> | 算术乘法 | <code>Mul</code> |
| <code>*=</code> | <code>var *= expr</code> | 算术乘法与赋值 | <code>MulAssign</code> |
| <code>*</code> | <code>*expr</code> | 解引用 | |
| <code>*</code> | <code>*const type</code>, <code>*mut type</code> | 原生指针 | |
| <code>+</code> | <code>trait + trait</code>, <code>'a + trait</code> | 复合类型限制 | |
| <code>+</code> | <code>expr + expr</code> | 算术加法 | <code>Add</code> |
| <code>+=</code> | <code>var += expr</code> | 算术加法与赋值 | <code>AddAssign</code> |
| <code>,</code> | <code>expr, expr</code> | 参数以及元素分隔符 | |
| <code>-</code> | <code>- expr</code> | 算术取负 | <code>Neg</code> |
| <code>-</code> | <code>expr - expr</code> | 算术减法| <code>Sub</code> |
| <code>-=</code> | <code>var -= expr</code> | 算术减法与赋值 | <code>SubAssign</code> |
| <code>-&gt;</code> | <code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code> | 函数与闭包，返回类型 | |
| <code>.</code> | <code>expr.ident</code> | 成员访问 | |
| <code>..</code> | <code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code> | 右半开区间 | PartialOrd |
| <code>..=</code> | <code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code> | 闭合区间 | PartialOrd |
| <code>..</code> | <code>..expr</code> | 结构体更新语法 | |
| <code>..</code> | <code>variant(x, ..)</code>, <code>struct_type { x, .. }</code> | “代表剩余部分”的模式绑定 | |
| <code>...</code> | <code>expr...expr</code> | (不推荐使用，用<code>..=</code>替代) 闭合区间 | |
| <code>/</code> | <code>expr / expr</code> | 算术除法 | <code>Div</code> |
| <code>/=</code> | <code>var /= expr</code> | 算术除法与赋值 | <code>DivAssign</code> |
| <code>:</code> | <code>pat: type</code>, <code>ident: type</code> | 约束 | |
| <code>:</code> | <code>ident: expr</code> | 结构体字段初始化 | |
| <code>:</code> | <code>'a: loop {...}</code> | 循环标志 | |
| <code>;</code> | <code>expr;</code> | 语句和语句结束符 | |
| <code>;</code> | <code>[...; len]</code> | 固定大小数组语法的部分 | |
| <code>&lt;&lt;</code> | <code>expr &lt;&lt; expr</code> |左移 | <code>Shl</code> |
| <code>&lt;&lt;=</code> | <code>var &lt;&lt;= expr</code> | 左移与赋值| <code>ShlAssign</code> |
| <code>&lt;</code> | <code>expr &lt; expr</code> | 小于比较 | <code>PartialOrd</code> |
| <code>&lt;=</code> | <code>expr &lt;= expr</code> | 小于等于比较 | <code>PartialOrd</code> |
| <code>=</code> | <code>var = expr</code>, <code>ident = type</code> | 赋值/等值 | |
| <code>==</code> | <code>expr == expr</code> | 等于比较 | <code>PartialEq</code> |
| <code>=&gt;</code> | <code>pat =&gt; expr</code> | 匹配分支语法的部分 | |
| <code>&gt;</code> | <code>expr &gt; expr</code> | 大于比较 | <code>PartialOrd</code> |
| <code>&gt;=</code> | <code>expr &gt;= expr</code> | 大于等于比较 | <code>PartialOrd</code> |
| <code>&gt;&gt;</code> | <code>expr &gt;&gt; expr</code> | 右移 | <code>Shr</code> |
| <code>&gt;&gt;=</code> | <code>var &gt;&gt;= expr</code> | 右移与赋值 | <code>ShrAssign</code> |
| <code>@</code> | <code>ident @ pat</code> | 模式绑定 | |
| <code>^</code> | <code>expr ^ expr</code> | 按位异或 | <code>BitXor</code> |
| <code>^=</code> | <code>var ^= expr</code> | 按位异或与赋值 | <code>BitXorAssign</code> |
| <code>|</code> | <code>pat | pat</code> | 模式匹配中的多个可选条件 | |
| <code>|</code> | <code>expr | expr</code> | 按位或 | <code>BitOr</code> |
| <code>|=</code> | <code>var |= expr</code> | 按位或与赋值 | <code>BitOrAssign</code> |
| <code>||</code> | <code>expr || expr</code> | 逻辑或 | |
| <code>?</code> | <code>expr?</code> | 错误传播 | |</p>
<h3 id="非运算符符号"><a class="header" href="#非运算符符号">非运算符符号</a></h3>
<p><span class="caption">表 B-2：独立语法</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>生命周期名称或循环标签</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, 等</td><td>指定类型的数值常量</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>字符串常量</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>原生字符串, 未转义字符</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>字节字符串; 结果是一个 <code>[u8]</code> 类型而非<code>string</code>类型</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, 等</td><td>原生字节字符串，原生和字节字符串字面值的结合</td></tr>
<tr><td><code>'...'</code></td><td>Char字符</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII字节</td></tr>
<tr><td><code>|...| expr</code></td><td>闭包</td></tr>
<tr><td><code>!</code></td><td>代表总是空的类型，用于发散函数(无返回值函数)</td></tr>
<tr><td><code>_</code></td><td>模式绑定中表示忽略的意思；也用于增强整型字面值的可读性</td></tr>
</tbody></table>
<p>表 B-3展示了模块和对象调用路径的语法。</p>
<p><span class="caption">表 B-3：路径相关语法</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>命名空间路径</td></tr>
<tr><td><code>::path</code></td><td>从当前的包的根路径开始的相对路径</td></tr>
<tr><td><code>self::path</code></td><td>与当前模块相对的路径（如一个显式相对路径）</td></tr>
<tr><td><code>super::path</code></td><td>与父模块相对的路径</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>关联常量、关联函数、关联类型</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>不可以被直接命名的关联项类型（如 <code>&lt;&amp;T&gt;::...</code>，<code>&lt;[T]&gt;::...</code>， 等）</td></tr>
<tr><td><code>trait::method(...)</code></td><td>使用特征名进行方法调用，以消除方法调用的二义性</td></tr>
<tr><td><code>type::method(...)</code></td><td>使用类型名进行方法调用, 以消除方法调用的二义性</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>将类型转换为特征，再进行方法调用,以消除方法调用的二义性</td></tr>
</tbody></table>
<p>表 B-4 展示了使用泛型参数时用到的符号。</p>
<p><span class="caption">表 B-4：泛型</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>为一个类型中的泛型指定具体参数（如 <code>Vec&lt;u8&gt;</code>）</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>为一个泛型、函数或表达式中的方法指定具体参数，通常指双冒号(turbofish)（如 <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>）</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>泛型函数定义</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>泛型结构体定义</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>泛型枚举定义</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>实现泛型</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>高阶生命周期限制</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>泛型，其一个或多个相关类型必须被指定为特定类型（如 <code>Iterator&lt;Item=T&gt;</code>）</td></tr>
</tbody></table>
<p>表 B-5 展示了使用特征约束来限制泛型参数的符号。</p>
<p><span class="caption">表 B-5: 特征约束</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>泛型参数 <code>T</code>需实现<code>U</code>类型</td></tr>
<tr><td><code>T: 'a</code></td><td>泛型 <code>T</code> 的生命周期必须长于 <code>'a</code>（意味着该类型不能传递包含生命周期短于 <code>'a</code> 的任何引用）</td></tr>
<tr><td><code>T : 'static</code></td><td>泛型 T只能使用声明周期为'static的引用</td></tr>
<tr><td><code>'b: 'a</code></td><td>生命周期<code>'b</code>必须长于生命周期<code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>使用一个不定大小的泛型类型</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>多个类型组成的复合类型限制</td></tr>
</tbody></table>
<p>表 B-6 展示了宏以及在一个对象上定义属性的符号。</p>
<p><span class="caption">表 B-6: 宏与属性</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>外部属性</td></tr>
<tr><td><code>#![meta]</code></td><td>内部属性</td></tr>
<tr><td><code>$ident</code></td><td>宏替换</td></tr>
<tr><td><code>$ident:kind</code></td><td>宏捕获</td></tr>
<tr><td><code>$(…)…</code></td><td>宏重复</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>宏调用</td></tr>
</tbody></table>
<p>表 B-7 展示了写注释的符号。</p>
<p><span class="caption">表 B-7: 注释</span></p>
<table><thead><tr><th>符号</th><th>注释</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>行注释</td></tr>
<tr><td><code>//!</code></td><td>内部行(hang)文档注释</td></tr>
<tr><td><code>///</code></td><td>外部行文档注释</td></tr>
<tr><td><code>/*...*/</code></td><td>块注释</td></tr>
<tr><td><code>/*!...*/</code></td><td>内部块文档注释</td></tr>
<tr><td><code>/**...*/</code></td><td>外部块文档注释</td></tr>
</tbody></table>
<p>表 B-8 展示了出现在使用元组时的符号。</p>
<p><span class="caption">表 B-8: 元组</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>空元组（亦称单元），即是字面值也是类型</td></tr>
<tr><td><code>(expr)</code></td><td>括号表达式</td></tr>
<tr><td><code>(expr,)</code></td><td>单一元素元组表达式</td></tr>
<tr><td><code>(type,)</code></td><td>单一元素元组类型</td></tr>
<tr><td><code>(expr, ...)</code></td><td>元组表达式</td></tr>
<tr><td><code>(type, ...)</code></td><td>元组类型</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>函数调用表达式；也用于初始化元组结构体 <code>struct</code> 以及元组枚举 <code>enum</code> 变体</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>元组索引</td></tr>
</tbody></table>
<p>表 B-9 展示了使用大括号的上下文。</p>
<p><span class="caption">表 B-9: 大括号</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>代码块表达式</td></tr>
<tr><td><code>Type {...}</code></td><td>结构体字面值</td></tr>
</tbody></table>
<p>表 B-10 展示了使用方括号的上下文。</p>
<p><span class="caption">表 B-10: 方括号</span></p>
<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>数组</td></tr>
<tr><td><code>[expr; len]</code></td><td>数组里包含<code>len</code>个<code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>数组里包含了<code>len</code>个<code>type</code>类型的对象</td></tr>
<tr><td><code>expr[expr]</code></td><td>集合索引。 重载（<code>Index</code>, <code>IndexMut</code>）</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>集合索引，也称为集合切片，索引要实现以下特征中的其中一个：<code>Range</code>，<code>RangeFrom</code>，<code>RangeTo</code> 或 <code>RangeFull</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-c可派生的-trait"><a class="header" href="#附录-c可派生的-trait">附录 C：可派生的 trait</a></h2>
<p>在本书的各个部分中，我们讨论了可应用于结构体和枚举定义的 <code>derive</code> 属性。被<code>derive</code>标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p>
<p>在本附录中,我们列举了所有标准库存在的<code>derive</code>特征，每个特征覆盖了以下内容</p>
<ul>
<li>该特征将会派生什么样的操作符和方法</li>
<li>由<code>derive</code> 提供什么样的特征实现</li>
<li>实现特征对于类型意味着什么</li>
<li>你需要什么条件来实现该特征</li>
<li>特征示例</li>
</ul>
<p>如果你希望不同于 <code>derive</code> 属性所提供的行为，请查阅 <a href="https://doc.rust-lang.org/std/index.html">标准库文档</a> 中每个特征的细节以了解如何手动实现它们。</p>
<p>除了本文列出的特征之外，标准库中定义的其它特征不能通过 <code>derive</code> 在类型上实现。这些特征不存在有意义的默认行为，所以由你负责以合理的方式实现它们。</p>
<p>一个无法被派生的特征例子是为终端用户处理格式化的 <code>Display</code> 。你应该时常考虑使用合适的方法来为终端用户显示一个类型。终端用户应该看到类型的什么部分？他们会找出相关部分吗？对他们来说最关心的数据格式是什么样的？Rust 编译器没有这样的洞察力，因此无法为你提供合适的默认行为。</p>
<p>本附录所提供的可派生特征列表其实并不全面：库可以为其内部的特征实现 <code>derive</code>，因此除了本文列出的标准库<code>derive</code>之外，还有很多很多其它库的<code>derive</code>。实现 <code>derive</code> 涉及到过程宏的应用，这在第十九章的 <a href="appendix/../macro/intro">宏</a>中有介绍。</p>
<h3 id="用于程序员debug输出的-debug"><a class="header" href="#用于程序员debug输出的-debug">用于程序员Debug输出的 <code>Debug</code></a></h3>
<p><code>Debug</code>特征可以让指定对象输出调试格式的字符串，通过在 <code>{}</code> 占位符中增加 <code>:?</code> 表明，例如<code>println!(&quot;show you some debug info: {}&quot;, MyObject);</code>.</p>
<p><code>Debug</code>特征允许以调试为目的来打印一个类型的实例，所以程序员可以在执行过程中看到该实例的具体信息。</p>
<p>例如，在使用 <code>assert_eq!</code> 宏时，<code>Debug</code>特征是必须的。如果断言失败，这个宏就把给定实例的值打印出来，这样程序员就能看到两个实例为什么不相等。</p>
<h3 id="相等比较的-partialeq-和-eq"><a class="header" href="#相等比较的-partialeq-和-eq">相等比较的 <code>PartialEq</code> 和 <code>Eq</code></a></h3>
<p><code>PartialEq</code>特征可以比较一个类型的实例以检查是否相等，并开启了 <code>==</code> 和 <code>!=</code> 运算符的功能。</p>
<p>派生的 <code>PartialEq</code> 实现了 <code>eq</code> 方法。当 <code>PartialEq</code> 在结构体上派生时，只有<em>所有</em> 的字段都相等时两个实例才相等，同时只要有任何字段不相等则两个实例就不相等。当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。</p>
<p>例如，当使用 <code>assert_eq!</code> 宏时，需要比较一个类型的两个实例是否相等，则 <code>PartialEq</code>特征是必须的。</p>
<p><code>Eq</code>特征没有方法, 其作用是表明每一个被标记类型的值都等于其自身。<code>Eq</code>特征只能应用于那些实现了 <code>PartialEq</code> 的类型，但并非所有实现了 <code>PartialEq</code> 的类型都可以实现 <code>Eq</code>。浮点类型就是一个例子：浮点数的实现表明两个非数字（<code>NaN</code>，not-a-number）值是互不相等的。</p>
<p>例如，对于一个 <code>HashMap&lt;K, V&gt;</code> 中的 key 来说， <code>Eq</code> 是必须的，这样 <code>HashMap&lt;K, V&gt;</code> 就可以知道两个 key 是否一样。</p>
<h3 id="partialord-和-ord用于次序比较"><a class="header" href="#partialord-和-ord用于次序比较"><code>PartialOrd</code> 和 <code>Ord</code>用于次序比较</a></h3>
<p><code>PartialOrd</code> 特征可以让一个类型的多个实例实现排序功能。实现了 <code>PartialOrd</code> 的类型可以使用 <code>&lt;</code>、 <code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 操作符。一个类型想要实现<code>PartialOrd</code>的前提是该类型已经实现了<code>PartialEq</code>。</p>
<p>派生 <code>PartialOrd</code> 实现了 <code>partial_cmp</code> 方法，一般情况下其返回一个 <code>Option&lt;Ordering&gt;</code>，但是当给定的值无法进行排序时将返回 <code>None</code>。尽管大多数类型的值都可以比较，但一个无法产生顺序的例子是：浮点类型的非数字值。当在浮点数上调用 <code>partial_cmp</code> 时，<code>NaN</code> 的浮点数将返回 <code>None</code>。</p>
<p>当在结构体上派生时，<code>PartialOrd</code> 以在结构体定义中字段出现的顺序比较每个字段的值来比较两个实例。当在枚举上派生时，认为在枚举定义中声明较早的枚举项小于其后的枚举项。</p>
<p>例如，对于来自于 <code>rand</code>包的 <code>gen_range</code> 方法来说，当在一个大值和小值指定的范围内生成一个随机值时，<code>PartialOrd</code> trait 是必须的。</p>
<p>对于派生了<code>Ord</code>特征的类型，任何两个该类型的值都能进行排序。<code>Ord</code>特征实现了 <code>cmp</code> 方法，它返回一个 <code>Ordering</code> 而不是 <code>Option&lt;Ordering&gt;</code>，因为总存在一个合法的顺序。一个类型要想使用<code>Ord</code>特征，它必须要先实现<code>PartialOrd</code> 和 <code>Eq</code>。当在结构体或枚举上派生时， <code>cmp</code>方法 和<code>PartialOrd</code>的 <code>partial_cmp</code>方法表现是一致的。</p>
<p>例如，当在 <code>BTreeSet&lt;T&gt;</code>（一种基于有序值存储数据的数据结构）上存值时，<code>Ord</code> 是必须的。</p>
<h3 id="clone-和-copy用于值复制"><a class="header" href="#clone-和-copy用于值复制"><code>Clone</code> 和 <code>Copy</code>用于值复制</a></h3>
<p><code>Clone</code>特征用于创建一个值的深拷贝（deep copy），复制过程可能包含代码的执行以及堆上数据的复制。查阅 <a href="appendix/../core/ownership.html#%E9%80%9A%E8%BF%87Clone%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">“通过Clone来进行深拷贝”</a>获取有关 <code>Clone</code> 的更多信息。</p>
<p>派生 <code>Clone</code> 实现了 <code>clone</code> 方法，当为整个的类型实现<code>Clone</code>时，在该类型的每一部分上都会调用<code>clone</code> 方法。这意味着类型中所有字段或值也必须实现了 <code>Clone</code>，这样才能够派生 <code>Clone</code> 。</p>
<p>例如，当在一个切片（slice）上调用 <code>to_vec</code> 方法时，<code>Clone</code> 是必须的。切片只是一个引用，并不拥有其所包含的实例数据，但是从 <code>to_vec</code> 中返回的Vector需要拥有实例数据，因此，<code>to_vec</code> 需要在每个元素上调用 <code>clone</code>来逐个复制。因此，存储在切片中的类型必须实现 <code>Clone</code>。</p>
<p><code>Copy</code>特征允许你通过只拷贝存储在栈上的数据来复制值(浅拷贝),而无需复制存储在堆上的底层数据。查阅第四章<a href="appendix/../core/ownership.html#%E9%80%9A%E8%BF%87Copy%E5%A4%8D%E5%88%B6%E6%A0%88%E6%95%B0%E6%8D%AE">通过Copy复制栈数据</a> 的部分来获取有关 <code>Copy</code> 的更多信息。</p>
<p>实际上<code>Copy</code>特征并不阻止你在实现时使用了深拷贝，只是，我们不应该这么做，毕竟遵循一个语言的惯例是很重要的。当用户看到<code>Copy</code>时，潜意识就应该知道这是浅拷贝，复制一个值会非常快。</p>
<p>当一个类型的内部字段全部实现了<code>Copy</code>时，你就可以在该类型上派上<code>Copy</code>特征。 一个类型如果要实现<code>Copy</code>它必须先实现<code>Clone</code>，因为一个类型实现<code>Clone</code>后，就等于顺便实现了<code>Copy</code>。</p>
<p>总之，<code>Copy</code>拥有更好的性能，当浅拷贝足够的时候，就不要使用<code>Clone</code>，不然会导致你的代码运行更慢，对于<a href="appendix/../performance/intro.html">性能优化</a>来说，一个很大的方面就是减少热点路径深拷贝的发生。</p>
<h3 id="hash用于实现值映射内存存储"><a class="header" href="#hash用于实现值映射内存存储"><code>Hash</code>用于实现值映射内存存储</a></h3>
<p><code>Hash</code>特征允许你使用<code>hash</code>函数把一个任意大小的实例映射到一个固定大小的值上。派生 <code>Hash</code> 实现了 <code>hash</code> 方法，对某个类型进行<code>hash</code>调用，其实就是对该类型下每个字段单独进行<code>hash</code>调用，然后把结果进行汇总，这意味着该类型下的所有的字段也必须实现了 <code>Hash</code>，这样才能够派生 <code>Hash</code>。</p>
<p>例如，在 <code>HashMap&lt;K, V&gt;</code> 上存储数据，存放 key 的时候，<code>Hash</code> 是必须的。</p>
<h3 id="default用于获取默认值"><a class="header" href="#default用于获取默认值"><code>Default</code>用于获取默认值</a></h3>
<p><code>Default</code>特征会帮你创建一个类型的默认值。 派生<code>Default</code>意味着自动实现了 <code>default</code> 函数。<code>default</code> 函数的派生实现调用了类型每部分的 <code>default</code> 函数，这意味着类型中所有的字段也必须实现了 <code>Default</code>，这样才能够派生 <code>Default</code> 。</p>
<p><code>Default::default</code> 函数通常结合结构体更新语法一起使用，这在第五章的 <a href="appendix/../basic/compound-type/struct.html#%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95">结构体更新语法</a> 部分有讨论。可以自定义一个结构体的一小部分字段而剩余字段则使用 <code>..Default::default()</code> 设置为默认值。</p>
<p>例如，当你在 <code>Option&lt;T&gt;</code> 实例上使用 <code>unwrap_or_default</code> 方法时，<code>Default</code>特征是必须的。如果 <code>Option&lt;T&gt;</code> 是 <code>None</code>的话, <code>unwrap_or_default</code> 方法将返回<code>T</code> 类型的 <code>Default::default</code> 的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录-drust版本"><a class="header" href="#附录-drust版本">附录 D：Rust版本</a></h2>
<p>早在第一章，我们见过 <code>cargo new</code> 在 <em>Cargo.toml</em> 中增加了一些有关 <code>edition</code> 的元数据。本附录将解释其意义！</p>
<p>与其它语言相比，Rust的更新迭代较为频繁(得益于精心设计过的发布流程以及Rust语言开发者团队管理)：</p>
<ul>
<li>每6周发布一个迭代版本</li>
<li>2-3年发布一个新的大版本：Rust 2021 edtion, 每一个版本会结合已经落地的功能，并提供一个清晰的带有完整更新文档和工具的功能包。新版本会作为常规的 6 周发布过程的一部分发布。</li>
</ul>
<p>好处在于，可以满足不同的用户群体的需求：</p>
<ul>
<li>对于活跃的Rust用户，他们总是能很快获取到新的语言内容，毕竟，尝鲜是技术爱好者的共同特点:)</li>
<li>对于一般的用户，edition的发布会告诉这些用户：Rust语言相比上次大版本发布，有了重大的改进，值得一看</li>
<li>对于Rust语言开发者，可以让他们的工作成果更快的被世人所知，不必锦衣夜行</li>
</ul>
<p>在本文档编写时，Rust 已经有三个版本：Rust 2015、2018、2021。本书基于 Rust 2021 edition 编写。</p>
<p><em>Cargo.toml</em> 中的 <code>edition</code> 字段表明代码应该使用哪个版本编译。如果该字段不存在，其默认为 <code>2021</code> 以提供后向兼容性。</p>
<p>每个项目都可以选择不同于默认的 2021 edition 的版本。这样，版本可能会包含不兼容的修改，比如新版本中新增的关键字可能会与老代码中的标识符冲突并导致错误。不过，除非你选择应用这些修改，否则旧代码依然能够被便衣，即便你升级了编译器版本。</p>
<p>所有 Rust 编译器都支持任何之前存在的编译器版本，并可以链接任何支持版本的包。编译器修改只影响最初的解析代码的过程。因此，如果你使用 Rust 2021 而某个依赖使用 Rust 2018，你的项目仍旧能够编译并使用该依赖。反之，若项目使用 Rust 2018 而依赖使用 Rust 2021 亦可工作。</p>
<p>有一点需要明确：大部分功能在所有版本中都能使用。开发者使用任何 Rust 版本将能继续接收最新稳定版的改进。然而在一些情况，主要是增加了新关键字的时候，则可能出现了只能用于新版本的功能。只需切换版本即可利用新版本的功能。</p>
<p>请查看 <a href="https://rust-lang-nursery.github.io/edition-guide/">Edition Guide</a> 了解更多细节，这是一个完全介绍版本的书籍，包括如何通过 <code>cargo fix</code> 自动将代码迁移到新版本。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录e-rust自身开发流程"><a class="header" href="#附录e-rust自身开发流程">附录E Rust自身开发流程</a></h2>
<p>本附录介绍 Rust语言自身是如何开发的以及这如何影响作为 Rust 开发者的你。</p>
<h3 id="无停滞稳定"><a class="header" href="#无停滞稳定">无停滞稳定</a></h3>
<p>作为一个语言，Rust <strong>十分</strong> 注重代码的稳定性。我们希望 Rust 成为你代码坚实的基础，假如持续地有东西在变，这个希望就实现不了。但与此同时，如果不能实验新功能的话，在发布之前我们又无法发现其中重大的缺陷，而一旦发布便再也没有修改的机会了。</p>
<p>对于这个问题我们的解决方案被称为 “无停滞稳定”（“stability without stagnation”），其指导性原则是：无需担心升级到最新的稳定版 Rust。每次升级应该是无痛的，并应带来新功能，更少的 bug 和更快的编译速度。</p>
<h3 id="choo-choo--小火车发布流程启动"><a class="header" href="#choo-choo--小火车发布流程启动">Choo, Choo! ~~ 小火车发布流程启动</a></h3>
<p>开发Rust语言是基于一个<strong>火车时刻表</strong>来进行的：所有的开发工作在Master分支上完成，但是发布就像火车时刻表一样，拥有不同的时间，发布采用的软件发布列车模型，被用于思科IOS和等其它软件项目。Rust 有三个 <strong>发布通道</strong>（<em>release channel</em>）：</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable（稳定版）</li>
</ul>
<p>大部分 Rust 开发者主要采用稳定版通道，不过希望实验新功能的开发者可能会使用 nightly 或 beta 版。</p>
<p>如下是一个开发和发布过程如何运转的例子：假设 Rust 团队正在进行 Rust 1.5 的发布工作。该版本发布于 2015 年 12 月，这个版本和时间显然比较老了，不过这里只是为了提供一个真实的版本。Rust 新增了一项功能：一个 <code>master</code> 分支的新提交。每天晚上，会产生一个新的 nightly 版本。每天都是发布版本的日子，而这些发布由发布基础设施自动完成。所以随着时间推移，发布轨迹看起来像这样，版本一天一发：</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>每 6 周时间，是准备发布新版本的时候了！Rust 仓库的 <code>beta</code> 分支会从用于 nightly 的 <code>master</code> 分支产生。现在，有了两个发布版本：</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>大部分 Rust 用户不会主要使用 beta 版本，不过在 CI 系统中对 beta 版本进行测试能够帮助 Rust 发现可能的回归缺陷（regression）。同时，每天仍产生 nightly 发布：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>比如我们发现了一个回归缺陷。好消息是在这些缺陷流入稳定发布之前还有一些时间来测试 beta 版本！fix 被合并到 <code>master</code>，为此 nightly 版本得到了修复，接着这些 fix 将 backport 到 <code>beta</code> 分支，一个新的 beta 发布就产生了：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>第一个 beta 版的 6 周后，是发布稳定版的时候了！<code>stable</code> 分支从 <code>beta</code> 分支生成：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>好的！Rust 1.5 发布了！然而，我们忘了些东西：因为又过了 6 周，我们还需发布 <strong>新版</strong> Rust 的 beta 版，Rust 1.6。所以从 <code>beta</code> 生成 <code>stable</code> 分支后，新版的 <code>beta</code> 分支也再次从 <code>nightly</code> 生成：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>这被称为 “train model”，因为每 6 周，一个版本 “离开车站”（“leaves the station”），不过从 beta 通道到达稳定通道还有一段旅程。</p>
<p>Rust 每 6 周发布一个版本，如时钟般准确。如果你知道了某个 Rust 版本的发布时间，就可以知道下个版本的时间：6 周后。每 6 周发布版本的一个好的方面是下一班车会来得更快。如果特定版本碰巧缺失某个功能也无需担心：另一个版本很快就会到来！这有助于减少因临近发版时间而偷偷释出未经完善的功能的压力。</p>
<p>多亏了这个过程，你总是可以切换到下一版本的 Rust 并验证是否可以轻易的升级：如果 beta 版不能如期工作，你可以向 Rust 团队报告并在发布稳定版之前得到修复！beta 版造成的破坏是非常少见的，不过 <code>rustc</code> 也不过是一个软件，可能会存在 bug。</p>
<h3 id="不稳定功能"><a class="header" href="#不稳定功能">不稳定功能</a></h3>
<p>这个发布模型中另一个值得注意的地方：不稳定功能（unstable features）。Rust 使用一个被称为 “功能标记”（“feature flags”）的技术来确定给定版本的某个功能是否启用。如果新功能正在积极地开发中，其提交到了 <code>master</code>，因此会出现在 nightly 版中，不过会位于一个 <strong>功能标记</strong> 之后。作为用户，如果你希望尝试这个正在开发的功能，则可以在源码中使用合适的标记来开启，不过必须使用 nightly 版。</p>
<p>如果使用的是 beta 或稳定版 Rust，则不能使用任何功能标记。这是在新功能被宣布为永久稳定之前获得实用价值的关键。这既满足了希望使用最尖端技术的同学，那些坚持稳定版的同学也知道其代码不会被破坏。这就是无停滞稳定。</p>
<p>本书只包含稳定的功能，因为还在开发中的功能仍可能改变，当其进入稳定版时肯定会与编写本书的时候有所不同。你可以在网上获取 nightly 版的文档。</p>
<h3 id="rustup-和-rust-nightly-的职责"><a class="header" href="#rustup-和-rust-nightly-的职责">Rustup 和 Rust Nightly 的职责</a></h3>
<p>Rustup 使得改变不同发布通道的 Rust 更为简单，其在全局或分项目的层次工作。其默认会安装稳定版 Rust。例如为了安装 nightly：</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<p>你会发现 <code>rustup</code> 也安装了所有的 <strong>工具链</strong>（<em>toolchains</em>， Rust 和其相关组件）。如下是一位作者的 Windows 计算机上的例子：</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>如你所见，默认是稳定版。大部分 Rust 用户在大部分时间使用稳定版。你可能也会这么做，不过如果你关心最新的功能，可以为特定项目使用 nightly 版。为此，可以在项目目录使用 <code>rustup override</code> 来设置当前目录 <code>rustup</code> 使用 nightly 工具链：</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>现在，每次在 *~/需要nightly的项目/*下(在项目的根目录下，也就是Cargo.toml所在的目录) 调用 <code>rustc</code> 或 <code>cargo</code>，<code>rustup</code> 会确保使用 nightly 版 Rust。在你有很多 Rust 项目时大有裨益！</p>
<h3 id="rfc-过程和团队"><a class="header" href="#rfc-过程和团队">RFC 过程和团队</a></h3>
<p>那么你如何了解这些新功能呢？Rust 开发模式遵循一个 <strong>Request For Comments (RFC) 过程</strong>。如果你希望改进 Rust，可以编写一个提议，也就是 RFC。</p>
<p>任何人都可以编写 RFC 来改进 Rust，同时这些 RFC 会被 Rust 团队评审和讨论，他们由很多不同分工的子团队组成。这里是 <a href="https://www.rust-lang.org/governance">Rust 官网上</a> 所有团队的总列表，其包含了项目中每个领域的团队：语言设计、编译器实现、基础设施、文档等。各个团队会阅读相应的提议和评论，编写回复，并最终达成接受或回绝功能的一致。</p>
<p>如果功能被接受了，在 Rust 仓库会打开一个 issue，人们就可以实现它。实现功能的人可能不是最初提议功能的人！当实现完成后，其会合并到 <code>master</code> 分支并位于一个特性开关（feature gate）之后，正如 <a href="appendix/rust-dev.html#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%8A%9F%E8%83%BD">不稳定功能</a> 部分所讨论的。</p>
<p>在稍后的某个时间，一旦使用 nightly 版的 Rust 团队能够尝试这个功能了，团队成员会讨论这个功能在 nightly 中运行的情况，并决定是否应该进入稳定版。如果决定继续推进，特性开关会移除，然后这个功能就被认为是稳定的了！乘着“发布的列车”，最终在新的稳定版 Rust 中出现。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
